/**
 * @file robot_total_mode.h
 * @author 陈卓勋 电控组 UCAS-SAS 中国科学院大学机器人队
 * @brief 根据遥控器宏观判断步兵机器人的总状态（包括是否自动），让云台、底盘、发射控制任务根据总状态判断分状态，保证一致性
 *          另外，在.c文件中定义变量，记录robotAuto状态。
 *
 * @version 0.2
 * @date 2022-02-05 修改为四个模式：无力、普通车、小陀螺车、坏yaw走位车
 *                                 掉线    C       V        B
 *                                          上      中      下
 * 当键盘开始控制后，遥控器拨杆就暂时失去控制了。当拨杆状态发生改变，那么清除键盘控制标记，遥控器重新获得更改状态的权限
 * 
 * @copyright Copyright (c) 2022
 * 
 */

#ifndef ROBOT_TOTAL_MODE_H
#define ROBOT_TOTAL_MODE_H

// 底盘和云台都有被控量和控制量的切换。
// 目标来源：NUC？遥控器和键盘？
// 被控制：底盘电机旋转速度？yaw反馈ECD角度？
// 控制方法：底盘轮子电机旋转？pitch电机旋转？yaw电机旋转？

//version 0.1
// enum RobotState_e{
//     RobotState_e_Powerless,      // 无力状态，当遥控器掉线时使用，也便于在场上推动机器人运动。这时，所有机构发送零电流。
//                                 //auto 模式下，依然无力
//     RobotState_e_StickyYaw,      // 固定云台方位。对于我们第一版的、云台轴承阻力过大的机器人使用。这时，云台yaw发送零电压，底盘独立运动。
//                                 //遥控器左摇杆控制pitch俯仰和原地旋转，右摇杆控制前后左右平移。
//                                 //键盘wasd控制前后左右平移，鼠标控制pitch俯仰和原地旋转。
//                                 //鼠标相当于遥控器左摇杆，键盘wasd相当于遥控器右摇杆
//                             //当云台在场上卡住时，可以按下G手动切换到此模式。（表示云台yaw 寄了）yaw恒为0电流
//                             //需要提前获取云台指向角度。可在config里设置开启OLED输出云台ECD
//                                 //auto 模式下，pitch电机自动运动，底盘自动旋转。

                                
//     RobotState_e_GoodYawButNoFollow,    // 云台与底盘相对独立，底盘独立控制方位。
//                                         // 
//                                         // 可以用来测试云台的驱动能力
//                                         // 鼠标控制云台绝对角度旋转。（用yaw电机的旋转和pitch电机的旋转控制云台姿态绝对角度）
//                                         // wasd控制底盘前后运动、旋转速度。（直接控制底盘轮子电机转动速度，控制目标是底盘电机转动速度）
//                                         // 底盘前后方向是：键盘直接表示底盘坐标系中的速度

//     RobotState_e_ChassisFollowGimbal,    // 底盘跟随云台，只是跟随角度。这时，云台必须是能完全控制且为绝对角度控制的。
//                                     //亦即，需要GoodYawButNoFollow通过测试。
//                                     // 
//                                     // 可是这就和大阻力轴承StickYaw模式相同了。对于我们那个轴承二者没有区别
//                                     // 那么这个就只能作为底盘回正了（一键回正）
//                             // 底盘通过旋转自己减小和云台的角度差。云台受手动或者自动控制。云台为绝对角度控制，靠底盘旋转改变云台相对底盘ECD角度
//     RobotState_e_QuasiSpinner,   // 准小陀螺运动模式――用于没有电滑环但还是可以靠软件控制旋转一定圈数范围。
//                     // 此时云台是绝对角度控制，底盘是绝对角速度控制（闭环控制轮子电机转速，但是不管实际整体转速）
//                     // 按下shift键开启。使用宏定义确定是准小陀螺还是小陀螺
//     RobotState_e_Spinner,        // 小陀螺模式，此时云台绝对角度控制，底盘绝对角速度（同上）
// };

//version 0.2
//shift 开启摩擦轮，ctrl关闭摩擦轮
// 鼠标左键按一下发射一个，按住连发，右键按住允许nuc控制发射（nuc可以选择单发或者连发）
// cvb进入不同车的模式
// z开启自瞄
// x关闭自瞄
// 鼠标上下pitch，左右：在badyaw车里是整体左右旋转，在普通车和小陀螺车里是云台独立左右旋转
// 前后控制有两种。es或者ws。
// 云台在一定时间内控制无法到达指定位置，就放弃控制
enum RobotState_e{
    RobotState_e_Powerless,     //无力模式，遥控器掉线时进入

    RobotState_e_CommonCar,     //普通车模式，键盘控制底盘坐标系运动，edsfag分别对应前后平移、左右旋转、左右平移。
                                //鼠标控制云台独立旋转。
                                // 此时，遥控器左边摇杆控制底盘在底盘坐标系前后平移、左右旋转。右拨杆确定云台独立的旋转
                                // 拨杆朝上时进入，以及按c时进入
                                // auto NUC控制云台独立的方向

    RobotState_e_BadYawCar,     //坏yaw 车模式，比赛中yaw可能卡住。进入此模式时，会尝试回正云台，一定时间内回正不了就放弃
                                //wsad前后左右平移，鼠标pitch上下和整体旋转
                                // 此时，遥控器左边摇杆控制机器人在云台坐标系中前后左右平移，
                                //拨杆在下时进入，以及按b时进入
                                // auto NUC控制云台pitch和整体转向：角度PID控制获得的角速度乘以系数后交给底盘控制任务
                                

    RobotState_e_Spinner,       //小陀螺模式。云台根据机械结构自动确定是小陀螺还是准小陀螺。
                                //拨杆在中时进入，以及按v时进入
                                //遥控器左摇杆控制在云台坐标系下的前后左右平移，右摇杆控制云台旋转
                                // auto NUC控制云台独立方向
};

int robotIsAuto(void);  // 对外提供的接口，返回目前机器人是否自动
const enum RobotState_e * getRobotPresentMode(void);  //返回机器人当前状态指针
void robot_total_mode_task(void const *pvParameters);

#endif // !ROBOT_TOTAL_MODE_H

/*
抽象出各个数据之间的联系和本质。

PID和电机本身所处的环境有关。不随控制目标的单位改变而改变。




*/
