[TOC]







## 电控代码设计说明v2.0-2022年2月15日

陈卓勋 电控组 UCAS-SAS机器人队 中国科学院大学本科部

注：本文档是文档v1.0（《电控方案设计v1.0-2022年1月25日》）的补充。文档v1.0详细叙述过的代码、v15版本及其之前的设计的详细方案（包括总线号码分配）在此不再赘述。对于**这篇文档、机器人电控代码设计思路、代码的设计实现细节**，在**UCAS-RM2022寒假冬令营腾讯会议上**有**详细的讲解**，且**已经录屏**，发送到电控群内。

关于电控代码设计，在初级阶段需要**理解掌握原理后自己尝试编写**。在工程实现上，在什么都没有的情况下，我们一开始要实现一个**最简单**并且可以运行的版本，而后在此基础上改进。**应该先有自己的想法**：自己设计机器人的控制模式，而后再去参考开源设计看有哪些地方可以借鉴参考，哪些地方需要学习调研攻关。而不是在成品开源上直接修改为我们所需的代码。如果直接修改，可能会有一些没有注意的地方导致程序失控，并且成品开源过于复杂，功能太多，容易找不到重点。这些挫折提醒我们：**自己的脑袋里要有自己的机器人总体设计方案。要超越Robomaster这个比赛，追寻更加一般的、普遍的、有历史意义的机器人控制思想**，要有关于人工智能的思考。机器人是人工智能的实体。

什么控制着机器人的运动？在2021年12月到2022年1月7日之间，进行着相关思考。机器人的控制来源是它自己的大脑内部的思想。对于我们这个时代，是单片机内部的程序定义，不是遥控器的指令。机器人仿佛跟着遥控器的指令在跑，是因为它的大脑内部，就是去获取遥控器信息，做出相应运动。我们能控制机器人，完全是因为机器人想让我们控制。而机器人最本质的控制来源，还是它自己。因此，遥控机器人是存在危险的，它可能失控。当使用人工智能算法控制机器人的时候，又会出现什么问题呢？我们是不是应该在机器人的底层就增加一个屏蔽层，根据人类创造的最简单的控制逻辑，识别机器人想要干的事情，阻止一些危险行为呢？未来算法是否又会找到方法绕过这个屏蔽层呢？我们电控的工作，就是给予机器人大脑和脊髓，控制最基本的运动，也产生一些稍显智能的行为。基于反应控制、规划控制、混合控制等方法。未来对于集群机器人也加入一些集群控制的方法。在实现了机器人丝滑的运动后，才能在更高层次实现智能行为。因此电控组投入工作。

### 最简单的机器人控制架构设计

设计一个控制模式。在跟着学校的课程**认真学习C语言**后，对数据传递、数据的作用范围、多文件联合编译、头文件、变量的声明和初始化有了更深的理解。再结合积累的CPU、计算机硬件结构、操作系统等知识，终于想到了组织这些任务和传递数据的方法。

把系统分为3个层次。可以参考《电控方案设计v1.0-2022年1月25日》。机器人底层的数据，例如陀螺仪数据、can总线数据、串口通信数据，依靠中断和DMA（直接存储访问，一种不过多耗费CPU工作时间的传输方式）传输实现。最初的版本没有考虑数据接收到的时刻的问题，因此没有离线检测的功能，但是对于最初版本的调试已经足够了。而高层次的任务，依靠单片机操作系统的调度实现，有不同的优先级和运行时间。高层次任务要获取数据，需要调用一次低层次任务提供的函数用于初始化一个指针变量。这个函数返回一个指针，指向低层次任务获取更新的数据。这个数据实时变化，因此高层次任务有了这个指针，就可以一直使用最新的数据。

### 设计过程和历史

在2021-2022秋季学期期末，2022年1月6日，C语言五子棋比赛的前一晚，从v1开始，一步步从底层加模块。不断根据教程自己在CubeMX和μvision上设置引脚、编写程序，完成了can通信、加速度计、LED灯等基础任务。每个任务的操作过程都在一个word文档里被详细记录，代码和文档转发到了电控群内。操作过程包括官方教程里没有提到的一些引脚配置。那些引脚配置是通过对比自己编写的代码和官方教程的示例代码而后发现的。因此，**也许代码才是讲得最详细的老师**。记录word是因为每一个模块是分开编写和配置的，之后在将所有代码合并在一起的时候，还需要重复配置。因此，在完成小任务时编写文档，可以帮助自己在以后重新配置。也可以作为交流的文档**帮助队友，相互启发**。

1月23日，实现了v15。v15是一个里程碑，实现了机器人最基础的底盘运动、云台pitch俯仰，发射。但是，毕竟是最简单的控制架构，缺少NUC通信、鼠标键盘操控、模式切换、掉线检测、裁判系统数据处理。无yaw的控制、无小陀螺、无单发射、无模式切换。云台控制是根据电机编码器（encoding）控制的，只有相对ECD角度控制，而无地面坐标系绝对的、以弧度为单位的角度控制。在得知组委会修改了评选方案：改为给所有队伍的完成度**排序**，排序靠前的才能通过，于是立刻推倒前面的最简单的设计，开始设计面向比赛的电控代码。

至少需要添加鼠标和键盘的控制方法才可能上场比赛。云台需要按照地面坐标系绝对角度控制才能实现小陀螺，因此需要实现姿态解算任务（这是一个锻炼机会，让大家去完成）。为了调试，需要有方法把数据输出出来，因此可以使用串口通信的方法（而这早在放假前几个星期就准备了：把线发给大家，让大家利用自己的51单片机开发板实现数据发送。后来结果挺好：电控组新队员们积极讨论，很快解决了无法通信的问题）。在参考了官方代码设计后，一开始决定像官方那样把云台分为多个状态：绝对角度控制、相对角度控制，底盘分为几个控制模式：跟随云台、不跟随云台等。但这样很快就混乱了，不知道自己要把机器人设计成什么样。后来重新编写了近千行云台任务后，却把单片机操作系统搞崩溃了。灯不亮了。有时灯会亮，但是很久很久才会变化一次，与设计的0.5s变化一次相去甚远。

2月2日，增加掉线监测、云台新控制方案后到达了**v20**。**在单片机操作系统任务调度又一次崩溃后**，开始反思。如今官方的开源方案如此完善，而我们重新慢慢从各个部件开始优化底层是无法追上最新的成果的。最后做出来也只是低层次的基本数据处理，没有在机器人的行为上反映出来。回忆我们造超级计算机的前辈。在玻璃房耻辱下，研发超级计算机，国内没有条件就到国外去焊板子。虽然没有自己研发的芯片，但是研发掌握了超级计算机整个体系的架构，而后使用国外芯片，完成了我们自己的超算，打破了玻璃房的耻辱。如今中国超算在世界领先。后来国外芯片不供货了，但是神威太湖之光已经使用自研芯片了。那我们如今造机器人，没有一个强大的底层，况且有一些东西是不开源的，**是否能先借助一个完善的底层，开发自己的机器人总控制架构，之后再去研发自主可控、更加强大的底层呢？**比如如今用C板和官步源码，之后拿龙芯来造？

于是试着直接烧录官方步兵的代码。官方步兵的摩擦轮和我们不一样。但是这个摩擦轮的问题已经在v15之前解决了。在《电控方案设计v1.0-2022年1月25日》中，已经分配好了我们这台步兵机器人的can总线号和ID号、报文发送和回传号。于是理论上至多只会出现摩擦轮不动的问题。然而烧录进去机器人却失控了。云台砰一下撞到边上，无法动弹。知道官步电控代码有校准任务，会识别限位装置、更新ECD数据，存放在flash中。于是把C板的芯片上的代码全部擦除，重新烧录。但还是会出问题。又觉得**应该脚踏实地从底层慢慢来**。

而后又回到自己从底层开始编写的v20代码。但在任务崩溃后又一次思考：**脚踏实地不是闭门造车。虽然直接改高层次任务不可取，但如果把官步的三个基本控制任务全部删除，改换为自己v15或者新的控制云台、底盘、发射控制代码又会如何呢？**我们使用官步开源电控，能够**获得C板所有的性能**，能读取和**解析裁判系统的数据**，那就**把官步代码当成一个底层**，删去三个高层次任务，而后自己编写整体的云台、底盘、发射控制架构，也许会行得通。

于是开始更改官步代码。删去高层次任务，用空任务替代原来的底盘控制任务；删除了用遥控器重置底盘电机ID的窒息操作，删除了与原来的那三个任务（云台、底盘、发射）相关联的一切任务，不断修改编译报错，像做手术一样切除组织缝合血管，用空函数或者永远返回成功的函数代替一些删除的函数，最终，编译通过。烧录，机器人不动。流水灯正常闪亮。OLED显示当前上线和掉线的任务。

```c
// 底盘空任务
#include "cmsis_os.h"
void chassis_task(void const *pvParameters)
{
    while(1)
    {
        osDelay(2);
    }
}

```

于是很高兴。趁着激动的心情，开CubeMX，增加了usart1的接收设置，在detect.c中增加了NUC离线监测代码，在OLED显示任务中增加显示NUC上线情况代码，移植之前写好的NUC通信接收处理代码。将自己编写的文件存放在文件夹SAS_code中。在freertos.c源代码中增加任务。测试，使用笔记本电脑的串口通信调试助手以100Hz频率发送28字节数据。机器人表示NUC上线。支持热插拔。

于是开始全力设计和编写高层次控制任务。**考虑到了之前的版本号增长太大了，因此决定使用v30.作为空机器人的版本号，用v30.0，v30.1,v30.2等代号给新的版本命名。**

又一次重新编写云台控制代码。但是700多行新代码在编写途中并没有测试。C板流水灯不亮了，改了几个地方，还是不亮。于是知道了，**在编写的过程中完成小模块后要一步一步测试**。这不只是验证**自己编写出来有没有错**，还是**验证编译器编译出来有没有错**。后者十分重要。有时自己编写出来是对的，但是编译器却编译出错误的程序。这需要靠一个模块一个模块地测试发现。这时，就修改代码，让语句更简单，加括号，把if判断分成几句来写，不要让编译器太累。然后得到正确的输出。

在C板空机器人程序中，发现了**usb任务**，打开代码，发现了一个usb_printf函数。直接连接电脑和C板的USB口，开串口调试助手，发现了usb串行设备。开启，获得了遥控器数据。发现了调试新方法！于是不管usart1的串口通信了，直接使用usb输出待调试的数据。后来有调试方法的变化。**最终的方法是：在云台任务中编写一个输出变量的函数，而OLED任务调用这个函数，输出值。OLED_printf可以自动换行，美哉。**这是这么久以来最方便的方法，不用重新生成一堆变量，也不用在待调试任务中编写一堆宏定义、判断输出和刷新的代码。

```c
///////////////////////////naive_shoot_task.c中的函数
void OLED_Shoot(void)
{
    OLED_printf(0,0,"t%d,presl:%d,swh:%d,Ins:fric=%d,one=%d,mul=%d,press:%d,trgMd:%d,fricOn:%d,trgOn:%d,round:%d,cur:%d",HAL_GetTick(), rc_p->mouse.press_l, rc_p->rc.s[SHOOT_MODE_CHANNEL],insBuff.turnOnFric,insBuff.shootOne,insBuff.shootMulti,pressTimeDebug,triggerMode,fricOn,triggerOn,triggerCtrl.nowRounds,giveShootCurrent[0]);
}

///////////////////////////
```

```c
//OLED_task里的部分函数
#ifdef SHOW_SHOOT_DATA
                OLED_Shoot();
#endif
                OLED_refresh_gram();
```

至于机器人控制代码的编写，后来转变思路。先**在纸上设计了机器人的所有控制模式**，精确到了键位和模式转换的按键和方法，明确了各个模式的应用场景。不考虑云台底盘有什么模式，只用考虑机器人本身处于一个什么模式，而后云台和底盘再根据这个模式的键位定义控制相应部件的运动就行了，而不用设定云台和底盘的某些模式。

在不断编写、调试和思考的过程中，也有一些**冷静的思考创造**。实现了完善的圈数监测算法应用于准小陀螺模式，后来又应用于发射机构的单发旋转角度控制，机器人各个控制层次：效应器传感器等，有了分类和对本质的思考、统一单位、从小到大明确数量级、分步处理的思想。这些将在之后的数据接收和任务控制中结合具体代码和实验讲解。

2月9日完成v30.10，是一个里程碑。在重新设计和完成了高层次的任务、优化了发射设计和控制后，机器人的飞坡视频也拍摄完毕。

### 底层数据接收处理

参考《电控方案设计v1.0-2022年1月25日》和代码v1-v15（主要是v1）中的各个components相关的word文档的记录。此处从略。

### 高层任务构建

高层次最基本且最重要的有云台、底盘、发射任务。为了实现自瞄或者模式转换的统一，增加了离线监测任务和模式控制解析任务。后来离线监测任务更改为了使用官步开源代码的更加完善的监测任务。但**这些自主思考过程和研究历史可以帮助新手抓住最本质最重要的思想和控制方法**。

按照真实的设计和编写历史，v30.10的NUC的通信和离线检测先于云台、底盘、发射任务的实现。因为为了安全，当遥控器离线的时候，机器人应该进入无力状态。当NUC掉线的时候，机器人应该自动切换为手动控制状态，避免没有更新的数据导致机器人失控。所以需要先实现遥控器离线检测任务。而实现了这个任务后，很自然地就会顺便完成NUC的离线检测任务。实现离线检测后，在机器人总模式任务中实现模式自动切换。

#### 机器人总模式控制

为了模式的统一，为了避免云台和底盘模式的混乱，需要自顶向下设计。因此设计了一个机器人总模式控制任务。包括一个无力模式、三个运动模式和一个关于自动状态的记录变量。

```c
/**
 * @author 电控组 UCAS-SAS 中国科学院大学机器人队
 * @brief 根据遥控器宏观判断步兵机器人的总状态（包括是否自动），让云台、底盘、发射控制任务根据总状态判断分状态，保证一致性
 *          另外，在.c文件中定义变量，记录robotAuto状态。
 * @version 0.1
 * @date 2022-01-28 略
 * 
 * @version 0.2
 * @date 2022-02-05 修改为四个模式：无力、普通车、小陀螺车、坏yaw走位车
 *                                 掉线    C       V        B
 *                                          上      中      下
 * 当键盘开始控制后，遥控器拨杆就暂时失去控制了。当拨杆状态发生改变，那么清除键盘控制标记，遥控器重新获得更改状态的权限
 * 
 */

//version 0.2
//shift 开启摩擦轮，ctrl关闭摩擦轮
// 鼠标左键按一下发射一个，按住连发，右键按住允许nuc控制发射（nuc可以选择单发或者连发）
// cvb进入不同车的模式
// z开启自瞄
// x关闭自瞄
// 鼠标上下pitch，左右：在badyaw车里是整体左右旋转，在普通车和小陀螺车里是云台独立左右旋转
// 前后控制有两种。es或者ws。
// 云台在一定时间内控制无法到达指定位置，就放弃控制
enum RobotState_e{
    RobotState_e_Powerless,     //无力模式，遥控器掉线时进入

    RobotState_e_CommonCar,     //普通车模式，键盘控制底盘坐标系运动，edsfag分别对应前后平移、左右旋转、左右平移。
                                //鼠标控制云台独立旋转。
                                // 此时，遥控器左边摇杆控制底盘在底盘坐标系前后平移、左右旋转。右拨杆确定云台独立的旋转
                                // 拨杆朝上时进入，以及按c时进入
                                // auto NUC控制云台独立的方向

    RobotState_e_BadYawCar,     //坏yaw 车模式，比赛中yaw可能卡住。进入此模式时，会尝试回正云台，一定时间内回正不了就放弃
                                //wsad前后左右平移，鼠标pitch上下和整体旋转
                                // 此时，遥控器左边摇杆控制机器人在云台坐标系中前后左右平移，
                                //拨杆在下时进入，以及按b时进入
                                // auto NUC控制云台pitch和整体转向：角度PID控制获得的角速度乘以系数后交给底盘控制任务
                                

    RobotState_e_Spinner,       //小陀螺模式。云台根据机械结构自动确定是小陀螺还是准小陀螺。
                                //拨杆在中时进入，以及按v时进入
                                //遥控器左摇杆控制在云台坐标系下的前后左右平移，右摇杆控制云台旋转
                                // auto NUC控制云台独立方向
};
```

这4个模式是经过云台底盘独立模式控制、机器人总模式v0.1之后剩下来的，也是根据去年比赛的经验和今年这台步兵的机械结构所需要模式。

```
//***************全局变量*******************************//
static int robotAuto=0;     //用于记录机器人的auto状态
```

机器人总模式会根据键盘、遥控器和NUC的操作以及离线上线状态实时切换。

这是为机器人自动状态设计的变量模式。其他的任务，在访问机器人总模式时，需要先包含头文件

```c
#include "robot_total_mode.h"
```

而后调用函数获取机器人状态指针和机器人自动模式。

```c
int robotIsAuto(void);  // 对外提供的接口，返回目前机器人是否自动
const enum RobotState_e * getRobotPresentMode(void);  //返回机器人当前状态指针
```

关于实时切换，涉及一些控制流程。这个模式控制是一个任务，在freertos中建立了这个线程。而这个任务本身是一个函数。

```c
void robot_total_mode_task(void const *pvParameters);
```

死循环外初始化遥控器、NUC数据指针

```c
int8_t lastMode,nowMode;
rc_p=get_remote_control_point();
nuc_p=get_nuc_control_point();
nowMode=rc_p->rc.s[RC_ROBOT_MODE_CHANNEL];
robotAuto=0;
```

在一个死循环里，根据键盘按下的键和遥控器右上拨杆的位置更改模式。键盘按下后，可能到了另一个模式，而遥控器拨杆却依然在原来的位置，因此**为了避免更新后的状态被遥控器摇杆状态覆盖**，使用一个**变量记录键盘按键是否被按下**。当按下后，遥控器的模式就失效了。如果**遥控器拨杆重新移动，那么清除键盘记录**，重新让遥控器拨杆控制机器人模式。使用了变量记录上一次拨杆的位置，记录了键盘是否被按下。这在操作手指南中是：

> 三个模式都可以通过按键或者遥控器右拨杆的移动切换。键盘和拨杆冲突时，以最新变化的控制器（键盘或者遥控器拨杆）的命令为准。

```c

    while (1)
    {
        //*****************************第一版本：通过遥控器拨杆变换状态**//
        // NUC掉线时，强制变为手动模式
        // 遥控器掉线时，强制回到PowerLess状态
        // 当键盘有任何按键开始按下后，就转换到键盘和鼠标控制了
        // 键盘Z键按下，开启自动瞄准模式（拼音zi“自”），
        // 键盘X键按下，关闭自动瞄准模式（叉叉把自动瞄准叉去了）

        lastMode=nowMode;
        nowMode=rc_p->rc.s[RC_ROBOT_MODE_CHANNEL];
        if(lastMode!=nowMode)
            keyBoardAndMouseHasChanged=0;
        if(!keyBoardAndMouseHasChanged) //键鼠状态清除
        {
            if(switch_is_up(rc_p->rc.s[RC_ROBOT_MODE_CHANNEL]))
            {
                robotState=RobotState_e_CommonCar;
            }
            else if(switch_is_mid(rc_p->rc.s[RC_ROBOT_MODE_CHANNEL]))
            {
                robotState=RobotState_e_Spinner;
            }
            else if(switch_is_down(rc_p->rc.s[RC_ROBOT_MODE_CHANNEL]))
            {
                
                robotState=RobotState_e_BadYawCar;
            }
        }  
    
        //探测键盘鼠标状态
        if(rc_p->key.v & KEY_PRESSED_OFFSET_Z)
        {
            robotAuto=1;
            keyBoardAndMouseHasChanged=1;
        }
        if(rc_p->key.v & KEY_PRESSED_OFFSET_X)
        {
            robotAuto=0;
            keyBoardAndMouseHasChanged=1;
        }
        if(rc_p->key.v & KEY_PRESSED_OFFSET_C)  //c开启普通车
        {
            robotState=RobotState_e_CommonCar;
            keyBoardAndMouseHasChanged=1;
        }
        if(rc_p->key.v & KEY_PRESSED_OFFSET_V)  //v开启小陀螺
        {
            robotState=RobotState_e_Spinner;
            keyBoardAndMouseHasChanged=1;
        }
        if(rc_p->key.v & KEY_PRESSED_OFFSET_B)  //b开启卡yaw坏车
        {
            robotState=RobotState_e_BadYawCar;
            keyBoardAndMouseHasChanged=1;
        }
        

       
        //***********************************************************//


        //*********************掉线检测*******************************//
        if(toe_is_error(MINI_PC_TOE))
            robotAuto=0;
        if(toe_is_error(DBUS_TOE))
        {
            robotState=RobotState_e_Powerless;
            keyBoardAndMouseHasChanged=0;
        }
            
        //*************************************************************

        osDelay(ROBOT_MODE_TASK_TIME);
    }
}

```

这里，掉线检测更换模式是为了确保安全性。当NUC离线时，自动切换到手动模式。当遥控器离线是，切换到无力模式，清除键盘控制信息。

```c
//*********************掉线检测*******************************//
        if(toe_is_error(MINI_PC_TOE))
            robotAuto=0;
        if(toe_is_error(DBUS_TOE))
        {
            robotState=RobotState_e_Powerless;
            keyBoardAndMouseHasChanged=0;
        }
            
        //*************************************************************

```

而后，机器人底盘和云台将根据这些总模式决定自己的控制方式。

#### NUC通信和离线检测

这是为了实现自动瞄准。NUC（小电脑、miniPC）性能比较高，可以运行复杂的计算机视觉程序。摄像机将数据通过USB线传给NUC，而后NUC再将数据传给单片机。我们目前使用串口接收NUC传来的数据。当然可以用can总线，也可以直接用USB（C板上又USB口，STM32f4也有集成USB。但目前，通信依靠串口，能用。

串口通信实现起来和遥控器接收机数据接收一模一样。在CubeMX里设置，打开串口1的接收，使能DMA传输，使能中断。仿照遥控器接收机数据处理，先初步判断接收到的数据字节数，而后发送处理，把值存放在一个结构体全局变量里。这个结构体里是角度位置等信息。

以下是和视觉组约定的串口通信协议。待击打方位解析用球坐标系表示。C语言结构体有对齐的情况，结构体所占空间不一定是所有变量的长度相加。所以在设计顺序的时候。两个16位数据后才用一个32位数据。这样，让结构体总的大小等于所有变量长度相加。

```c
typedef struct 
{
    uint16_t startFlag;             // 0 1 开始标志 当发现装甲板时为'S',当未发现时为0
    uint16_t taskType;              // 2 3 当前任务类型，例如正在识别对方步兵装甲板
    fp32 theta;                     // 4 5 6 7 r与z轴夹角,弧度制单位，范围0-PI
    fp32 phi;                       // 8 9 10 11 r在xy平面投影与x正方向夹角，范围0-2*PI
    fp32 r;                         // 12 13 14 15 目标与摄像机距离,单位 米
    uint16_t detectedColor;         //16 17识别出来的目标物颜色
    uint16_t reserved[4];           //18 19 20 21 22 23 24 25保留位，用于以后制造全自动步兵时，单片机与nuc交互
    uint16_t endFlag;               //26 27 结束标志
} toSTM32_t;
```

###### 初始：自己编写任务记录时间

为了检测NUC是否掉线，一个思路是**每当数据来并且有效的时候，记录当前时间**。另外运行一个monitor_task,实时监测当前时间和数据最后一次有效时间差距是否过大。如果过大，判断NUC离线，而后设置NUC数据无效。对于遥控器数据也是这样处理。

如何记录当前时间？有一个获取系统滴答的函数HAL_GetTick。返回uint32_t数据，单位ms，足够40多天的时间了。

相关的接口函数，为监控任务设置有效和无效提供接口，为底盘等任务提供有效无效判断。

```c
static uint32_t lastValidTime=0;
static int dataIsValid=0; 

void setNUCValid(void)
{
    dataIsValid=1;
    return;
}
void setNUCInvalid(void)
{
    dataIsValid=0;
}
uint32_t getNUCLastValidTime_ms(void)
{
    return lastValidTime; 
}
int NUCIsValid(void)
{
    return dataIsValid;
}

```

在解析任务中，有设置NUC数据有效时间的代码，并且将NUC数据设置为有效。

```c
static void sbus_to_nucCtrl(volatile const uint8_t *sbus_buf, toSTM32_t *nuc_ctrl)
{
    if (sbus_buf == NULL || nuc_ctrl == NULL)
    {
        return;
    }
    lastValidTime=HAL_GetTick();//设置新的遥控器数据有效时间
    setNUCValid();

    // 从低位开始传??
    nuc_ctrl->startFlag=(sbus_buf[0]|(sbus_buf[1]<<8));
    nuc_ctrl->taskType=(sbus_buf[2]|(sbus_buf[3]<<8));
    nuc_ctrl->theta=sbus_buf[4]|(sbus_buf[5]<<8)|(sbus_buf[6]<<16)|(sbus_buf[7]<<24);
    nuc_ctrl->phi=sbus_buf[8]|(sbus_buf[9]<<8)|(sbus_buf[10]<<16)|(sbus_buf[11]<<24);
    nuc_ctrl->r=sbus_buf[12]|(sbus_buf[13]<<8)|(sbus_buf[14]<<16)|(sbus_buf[15]<<24);
    nuc_ctrl->detectedColor=(sbus_buf[16]|(sbus_buf[17]<<8));
    nuc_ctrl->reserved[0]=(sbus_buf[18]|(sbus_buf[19]<<8));
    nuc_ctrl->reserved[1]=(sbus_buf[20]|(sbus_buf[21]<<8));
    nuc_ctrl->reserved[2]=(sbus_buf[22]|(sbus_buf[23]<<8));
    nuc_ctrl->reserved[3]=(sbus_buf[24]|(sbus_buf[25]<<8));
    nuc_ctrl->endFlag=(sbus_buf[26]|(sbus_buf[27]<<8));
}
```

在底盘和云台任务中，可以使用这种方法，调用NUCIsValid()函数，判断数据是否有效，如果无效就切换到安全状态。**在使用官步框架改进系统性能后，这个方法被弃用了，转而使用detect_task的统一管理。**

###### 改进：使用官方步兵detect_task的框架

官步自带掉线监测功能。在自己设计并实现了一个简单的掉线监测系统后，一下子就明白了官步代码的工作方式。这说明**看不懂没关系，重要的是自己思考，而后就会发现原来别人的思路其实很自然，只不过别人走得很远，不断完善了这个灵感。**

根据提示添加设备——我们的NUC。

```c
//错误码以及对应设备顺序
enum errorList
{
    DBUS_TOE = 0,
    CHASSIS_MOTOR1_TOE,
    CHASSIS_MOTOR2_TOE,
    CHASSIS_MOTOR3_TOE,
    CHASSIS_MOTOR4_TOE,
    YAW_GIMBAL_MOTOR_TOE,
    PITCH_GIMBAL_MOTOR_TOE,
    TRIGGER_MOTOR_TOE,
    BOARD_GYRO_TOE,
    BOARD_ACCEL_TOE,
    BOARD_MAG_TOE,
    REFEREE_TOE,
    RM_IMU_TOE,
    OLED_TOE,
    MINI_PC_TOE,      // 我们的NUC
    ERROR_LIST_LENGHT,
};
```

官步代码对一个设备的上线和离线做出了抽象，总结了一个设备工作时的一些特征量。比如上线时间、工作时间、错误处理函数等。

```c
typedef __packed struct
{
    uint32_t new_time;
    uint32_t last_time;
    uint32_t lost_time;
    uint32_t work_time;
    uint16_t set_offline_time : 12;
    uint16_t set_online_time : 12;
    uint8_t enable : 1;
    uint8_t priority : 4;
    uint8_t error_exist : 1;
    uint8_t is_lost : 1;
    uint8_t data_is_error : 1;

    fp32 frequency;
    bool_t (*data_is_error_fun)(void);
    void (*solve_lost_fun)(void);
    void (*solve_data_error_fun)(void);
} error_t;

```

像我们之前写的monitor_task，官步代码也有一个监测任务。

```c
extern void detect_task(void const *pvParameters);
```

在底盘控制任务中，我们希望知道遥控器有无离线，若离线则设置底盘无力。而判断的接口，是

```c
extern bool_t toe_is_error(uint8_t err);
```

```c
//*********************掉线检测*******************************//
if(toe_is_error(MINI_PC_TOE))
    robotAuto=0;
```

而遥控器数据处理程序在收到数据后，需要**汇报设备工作的时刻**。这样，监控任务就知道上一次设备工作时刻是多久，和当前系统时间比较，就知道设备是否离线了。设备可以是NUC。汇报函数如下

```c
extern void detect_hook(uint8_t toe);
```

于是在nucCommu.c中，有

```c
if(this_time_rx_len == NUCINFO_FRAME_LENGTH)
{
    sbus_to_nucCtrl(nucinfo_rx_buf[0], &nuc_ctrl);
    detect_hook(MINI_PC_TOE);
}
```

#### 云台任务

在这几天编写了多个版本的代码。有的能正常工作，有的写完后用于指示操作系统工作状态的流水灯不亮了（如果流水灯正常闪亮，就说明任务调度依然正常），有的导致流水灯的工作周期变长了，有的在运行的过程中让流水灯卡了，机器人也停下了。在这个过程中，遇到问题，也研究出了解决方案。首先思考一些小问题。小问题的意思是决定成败的细节问题，而非不重要的问题。

###### 云台工作模式的确定

设计机器人总模式后，可以归纳云台需要工作的模式。只需要绝对角度控制、卡yaw模式和无力模式。那么**不需要在云台控制任务中单独使用状态机，直接根据总模式计算控制量。**

###### 控制量的确定

v30.10使用的**控制量很简洁**。角度全部用rad（弧度），角速度全部使用rad/s，PID参数只有两个，一个是角度环，一个是速度环。电机的ECD（电机编码器，encoding）只起到标记相对位置的作用。设置机器人无力，在OLED中输出当前ECD，调整机器人的yaw和pitch，电控队员把OLED显示的ECD值记录在纸上。而后修改程序对起始ECD、最大ECD、最小ECD的宏定义，就能让机器人正确在云台坐标系平移、控制最大角度。

最初希望使用角速度控制和角度控制。角度控制的单位为rad，而角速度控制的单位为ECD/ms（电机编码器，encoding），希望提高精度。然而编写过程中，却因此使用了多个PID参数：云台的速度环和角度环各有PID参数，由不同的单位（rad和ECD/ms），又有不同的PID参数，而后导致控制十分混乱。虽然采用了将所有角度，无论是rad还是ECD，全部化作fp32格式的ECD（基本的ECD是uint16_t，但是将fp32的陀螺仪数据传递过来时，会丢失精度，于是也采用fp32的ECD），但是静止时，电机ECD会有1的变化，而采样的周期又太短，10ms量级，导致反馈数据波动很大。类比瞬时速度的测量精度。如果时间间隔越小，得到的平均速度越接近瞬时速度，但时间短了后，又会导致距离测量误差增大，导致总误差增加。因此最后抛弃了ECD控制，直接使用姿态解算任务得到的绝对角度控制。

最初还希望遥控器和鼠标直接控制旋转速度，NUC控制绝对角度。但是这样又会导致最大角度限制难以实现。最初的思路是在角度超出范围并且遥控器控制速度加剧这个越界情况，就让速度为0。然而当pitch或者yaw接近最大角度且有较大速度时，它们就会由于惯性撞到外面去。因此，用遥控器和鼠标控制期望角度的加减，而后送入双环PID控制器，输出电压。

在一个版本的云台控制任务中，将yaw电机和pitch电机做了统一的抽象。都可以转过一定的圈数而后转过一定的角度，而pitch只是圈数上限为0，yaw圈数上限为3。**然而这样做抽象却暂时没有扩展的应用场景，反而增加了太多需要的变量。任务载入后，C板灯不亮，可能是超过了变量存储空间的上限了。因此，需要考虑适度的拓展性而非无穷的拓展性。**

最终，确定所有的方法都控制云台绝对角度。控制云台一个轴的信息如下。

```c
struct milestoneStack_s {
    uint8_t head;
    uint8_t stack[MILESTONE_NUMBER+1];
};
struct gimbalMotorCtrl_s{
    //rads
    const fp32 * anglePoint;          //从姿态解算任务得到的角度位置
    fp32 nowAbsoluteAngle;      //当前姿态角
    uint32_t nowTime;           //当前时间
    fp32 lastAbsoluteAngle;     //上次姿态角
    uint32_t lastTime;          //上次时间
    fp32 radSpeed;              //角速度 rad/s
    fp32 wantedAbsoluteAngle;   //目标姿态角

    //ECDs
    const uint16_t * ECDPoint;        //ECD参数所在位置
    uint16_t maxECD,minECD,middleECD,nowECD;    //最大、最小、中值、当前ECD
    int16_t nowRounds;          //现在转过的圈数
    int16_t maxRounds;          //转过的最大正负圈数
    struct milestoneStack_s mstack; //和圈数记录相关变量

    //PIDs
    pid_type_def spd_pid;       //用于控制速度的PID环。输入角速度 rad/s, 输出GM6020电压 int16
    pid_type_def agl_pid;       //用于控制角度的PID环。输入角度 rad,输出角速度rad/s

    //控制量
    int16_t giveVolt;       //GM6020发送电压
    uint8_t zeroVoltMark;
};

```

在设计云台的过程中，**思考所需的控制量，而后用笔在纸上记录，分类之后录入电脑，形成结构体**。用纸笔是因为纸笔很自由，想到什么就写什么，而且是在任意方位，画任何图和标记。如果大脑在输出的时候还要检查外界是否正确理解，就会消耗过多注意力。因此**纸笔在设计时依然很重要**。

###### 旋转圈数的监控

由于我们暂时没有电滑环，机器人无法实现恒定的单方向小陀螺运动。但是，可以用软件监控转过的圈数，到达一定圈数后，反向转动，实现一定程度的小陀螺。给对方的瞄准产生困难，躲避子弹。

最终的结果是：想出了一个算法监控转过的圈数，无论正转反转还是中途多次转向，都能够完善地监控圈数。取名：里程碑栈法。

最初，想到使用圈上的标记，当到达某一个位置时，根据此处的标记和别处的标记判断是转过了一圈还是没有转过一圈。由于云台自己会转动，底盘也会转动，速度不定，电机ECD编码不会单调变化。会有大量判断条件。使用if和else逐点判定，情况过多。还需要考虑标记的顺序。

后来，抽象出栈模型和里程碑模型。需要三个里程碑，作为位置判断标记，到达一个位置后，若此位置和栈顶位置不同，则入栈，这是为了避免同一个位置重复入栈（任务执行周期很短，采样频率很快）。在更新后的栈中，如果顶和自顶向下第三个数相同，则说明是连续通过了两个位置但而后又回到了第一个位置，因此让栈顶两个元素出栈；如果如果顶和自顶向下第三个数相同，并且栈顶和自顶向下第四个数相同，就说明转到了一圈。根据栈中的元素顺序（或者仅仅看第二个元素）可以判定转动的方向。

当然在实现上，有许多细节需要考虑。这里，最终方法是在迭代改进后形成的。

里程碑栈结构体。栈底的元素永远为0。栈的head，定义为最上面一个有元素的位置。

```C
struct milestoneStack_s {
    uint8_t head;
    uint8_t stack[MILESTONE_NUMBER+1];
};
```

到达里程碑的判定方法：根据ECD角度的差距判断。里程碑会是一个点的正负一段ECD的范围内。一开始是某一个里程碑位置双向判断，就会导致取值0~8191的ECD编码出现突变的问题。例如，8190显然是在0的负方向一点点的，双向判断时，属于里程碑的范围内。容易在判断时出现问题，进而可能导致数组越界等情况，危害机器人控制。

因此，需要对ECD值的运算结果做处理，统一化为某一个周期内的数值。就像角度的弧度单位的2π周期。为什么要做这个format呢？是因为把里程碑的起始位置设置在0、8192/3、8192/3*2的位置。正负（或者只是正）一段ECD距离，在宏定义里是 MILESTONE_NEAR_THRESHHOLD。而真实的电机的初始位置的ECD不一定是0，可能是0~8191内任何一个数。因此在系统初始化的时候，测量ECD，并且此后计算里程碑栈位置差距的时候，引用这个初始ECD，就可以得到从初始位置转1/3圈或者2/3圈的ECD值了。

```c
//*************************里程碑栈法的控制参数***********//
#define MILESTONE_NEAR_THRESHHOLD 200
#define MILESTONE_NUMBER 3

```

```c
/**
 * @brief 将ECD差值等化为(0,8191)范围
 * 
 * @param rawECD 
 * @return uint16_t 
 */
static uint16_t ECDFormat(int16_t rawECD)     //test done
{
    while(rawECD<0)
        rawECD+=ECD_FULL_ROUND;
    while(rawECD>=ECD_FULL_ROUND)
        rawECD-=ECD_FULL_ROUND;
    return (uint16_t)rawECD;
}
```

后来意识到，并不需要把某一个点的负方向作为里程碑的位置，我们只需要某一个点的正方向一段范围内作为这个里程碑的领地就行了。因此，在通过format之后得到一个非负数，只要小于一个不超过8191/3的正数就行了，这里在yaw电机上，可以取200（注：之后拨弹轮电机200是行不通的。拨弹轮由于转速太快，采样不够连续，阈值改成了2000）。

一些建议：**如果理解起来有困难，请自己设计一个圈数监控算法，而后就明白了。**

监测算法的实现。参数是控制结构体。里程碑栈在控制结构体内。不断更新当前ECD，运算，获得

```C
void monitorRounds(struct gimbalMotorCtrl_s * c)
{
    uint8_t j;
    for(j=0;j<MILESTONE_NUMBER;j++)    //枚举每一个里程碑所在位置
    {
        fp32 relativeRealECD;
        relativeRealECD=ECDFormat((int16_t)c->nowECD-(int16_t)c->middleECD);
        //失败原因是0的比较出现了问题
        
        if(ECDFormat(relativeRealECD-j*ECD_FULL_ROUND/MILESTONE_NUMBER)<MILESTONE_NEAR_THRESHHOLD)
                //当前位置落在相应里程碑点所在区域内
        {
            if(j!=(c->mstack.stack[c->mstack.head]))
               //不等说明到达了一个新位置，将此新位置加入栈中
            {
                c->mstack.head++;
                #ifdef WATCH_ARRAY_OUT
                if(c->mstack.head>=MILESTONE_NUMBER)
                {
                    itHappens();    //  让usb task输出此数组越界信息
                    c->mstack.head=MILESTONE_NUMBER-1;
                }
                    
                #endif
                c->mstack.stack[c->mstack.head]=j;
            }
        }
    }
    if(((c->mstack.head)-2)>=0)
    {
        if(c->mstack.stack[c->mstack.head]==c->mstack.stack[c->mstack.head-2])
            (c->mstack.head)-=2;
    }
    if(((c->mstack.head)-3)>=0)
    {
        if(c->mstack.stack[c->mstack.head]==c->mstack.stack[c->mstack.head-3])
        {//到达了一圈
            if(c->mstack.stack[1]==1)//正向旋转（逆时针）
                c->nowRounds +=1;
            else
                c->nowRounds -=1;
            c->mstack.head=0;     // 清空栈，回到初始为0的时候
        }
    }
}

```

其中，这是为了监控数组下标越界的情况。

```C
#ifdef WATCH_ARRAY_OUT
if(c->mstack.head>=MILESTONE_NUMBER)
{
    itHappens();    //  让usb task输出此数组越界信息
    c->mstack.head=MILESTONE_NUMBER-1;
}

#endif
```

###### 物理量本质、单位的统一、参数范围（弧度范围）的选取（一些数学物理思想）

最初几个版本，ECD单位和rad单位很混乱，有许多不同的PID参数其实是对同一个电机控制同一个物理量设置的。最终使用弧度制的角度控制。其一，角度可以直接由姿态解算任务得到，不需要太多变换；其二，用弧度每秒作为角速度单位可以让调试队员对电机的输出有一个大概的估计。这也是学习物理时所需要的**“数量级”的概念**。

在计算两个方位的角度差时，需要化为一个周期内的弧度制。在使用PID计算输出电压时，旋转方向由电压决定，误差决定了电压。希望能够以最短路径转到目标方向。最后采用(-PI,PI)的区间。好处在于：**角度的正负恰好对应了目标旋转方向**。

例如，在云台专用PID计算函数

```c
fp32 gimbal_PID_calc(pid_type_def *pid, fp32 ref, fp32 set);
```

中，PID的error计算是化为了(-PI,PI)内的

```c
pid->error[2] = pid->error[1];
    pid->error[1] = pid->error[0];
    pid->set = set;
    pid->fdb = ref;
    pid->error[0] = radFormat(set - ref);
```

```c
/**
 * @brief 将角度化为(-PI,PI)范围内
 * 
 * @param rawAngle 
 * @return fp32 
 */
fp32 radFormat(fp32 rawAngle)   //test done
{
    while(rawAngle>PI)
        rawAngle-=(2*PI);
    while(rawAngle<(-PI))
        rawAngle+=(2*PI);
    return rawAngle;
}
```

这说明了**一种合适的编码方式能够正好对应自然界中的现象，编码的特征也反应了自然界的某些特征**，也许这也是数学家和物理学家面对一个模型的神奇时的激动心情吧。

还有物理学家对于世界本质的反思。一个量到底反映什么样的本质？什么对象是在本质上同一种？可以有统一的数学描述？不断的程序挫折之后，有了对于控制层次的反思。机器人控制模式，各个部件的控制模式，部件上电机的控制目标。高层次的多样性来源于低层次的不同组合。一个高层次控制模式，可以写成一个低层次任务的目标参数组成的向量。（如何定义向量的模长？）那么就可以很简单而统一地描述不同的任务，统一使用一个计算方式，唯一的区别是计算过程中参量的取值。

具体到电机。一个电机所处的环境：力矩、阻力、载荷......电机本身的性质和环境决定了响应的速度和理想的PID参数。而这个参数应该是与单位无关的。无论是ECD作为单位还是rad作为单位。因此，yaw和pitch由于处于不同的位置驱动不同的结构，从角速度误差输入到控制电压输出的PID环应该是有不同的PID参数。而从角度误差到角速度输出，是一个相比于前一个环更加抽象的概念。它与在pitch还是在yaw无关，取决于“角度”和“角速度”这个抽象的量。

在进行了这些思考后，可以引导进行设计。在naive_gimbal_task中，虽然有两个双环共4个PID控制器，但是只有三组PID参数

```c
// 输入角速度 rad/s 、输出电压 int16_t 的PID系数
#define PITCH_SPD_KP 300000.0f
#define PITCH_SPD_KI 30.0f
#define PITCH_SPD_KD 0.0f

#define PITCH_VOLT_MAX_OUT  30000.0f
#define PITCH_VOLT_MAX_IOUT 5000.0f

#define YAW_SPD_KP 1500000.0f
#define YAW_SPD_KI 30.0f
#define YAW_SPD_KD 0.0f

#define YAW_VOLT_MAX_OUT  30000.0f
#define YAW_VOLT_MAX_IOUT 5000.0f


//输入角度 rad ，输出角速度rad/s 的PID系数
#define AGL_KP 0.11f
#define AGL_KI 0.0f
#define AGL_KD 0.0f

#define AGL_SPD_MAX_OUT (1.0f)
#define AGL_SPD_MAX_IOUT (0.7f)
```

注意到AGL_KI为0，这是调试的结果。如果不为0，会出现即便到达了目标位置依然电流过大的情况。

###### PID控制方法和控制目标的调试

云台最终控制目标是角度，为了改变角度，需要一定的角速度；为了改变角速度，需要一定的电压电流。因此修改电机电压只能产生角加速度，改变角速度，而后再改变速度。如果直接调节电压改变角度，可能会导致响应有偏差。

虽然我们没有直接控制角速度的应用场景，但是如果想要正确控制角度，首先需要控制角速度环的能力。目标量和调试量并不直观。因此通过usb线将目标角速度和当前角速度发送到电脑，查看是否存在静差。编写代码，通过遥控器摇杆位置计算目标量。第一次调PID胆子小，给的PID参数很小。用USB通信线查看调试量后，发现实际量比目标量小很多很大，这是因为KP过小。KP是主要的控制参数。由于当前步兵yaw很卡，角速度 rad/s 数值虽然小，但看起来还是挺快，因此KP达到了1500000.0f，巨大的数字。

调试的过程：编写控制程序，插上USB线，打开串口调试助手，修改一次PID参数后，编译上传程序，按下reset键C板重启。通过遥控器摇杆设置目标量，查看实际量能否跟上目标量。始终无法跟上，还是云台太卡了。最后数值很大。为了方便以后重新调节PID参数，已经把调PID时编写的usb输出、遥控器到速度的映射等都写在了v30.5和v30.6版本的程序中。未来直接烧录进机器人就可以开始调节PID参数。

当时使用的数据输出方法很麻烦。在gimbal文件声明了结构体变量数组，名称、长度、数值等。留下了数据接口

```c
struct gimbalToShow_s{
    char *name;
    fp32 value;
};

#ifdef GIMBAL_DEBUG_SHOW
struct gimbalToShow_s debuggShows[GIMBAL_DEBUG_SHOW_SERIES_NUMBER];
#endif

struct gimbalToShow_s * getGimbalSomethingToShow(void);	//让usb_task调用
```

在usb文件获取变量和输出数据。

```c
#ifdef GIMBAL_DEBUG_SHOW
        // uint8_t i;
            // for(i=0;i<GIMBAL_DEBUG_SHOW_SERIES_NUMBER;i++)
                usb_printf("%s:%f\r\n%s:%f\r\n%s:%f\r\n%s:%f\r\n%s:%f\r\n%s:%f\r\n%s:%f\r\n%s:%f\r\n%s:%f\r\n%s:%f\r\n%s:%f\r\n",things[0].name,things[0].value,
                things[1].name,things[1].value,things[2].name,things[2].value,
                things[3].name,things[3].value,things[4].name,things[4].value,
                things[5].name,things[5].value,things[6].name,things[6].value,
                things[7].name,things[7].value,things[8].name,things[8].value,
                things[9].name,things[9].value,things[10].name,things[10].value);
        #endif
```

这里要注意，不能使用循环printf输出（不能用for循环遍历things数组输出）。printf很慢，在电脑上接收会丢失数据。实验就知道了。

不过之后不会再用这样的方法了。之后会再gimbal函数中声明一个函数，这个函数直接使用usb_printf输出Gimbal文件中的变量。而后在usb_task中调用这个函数。省去了延时printf的麻烦。

###### PID控制器奇怪的行为，要清零

最初PID控制器在初始化后，运行过程中，fp32的数据有nan。这时，对控制器清零就行了。使用了函数

```c
PID_clear(&(gimbalYawCtrl.spd_pid));
```

而在v30.10正式的代码中，保留了这个设计。

```c
if(rc_p->rc.s[1]==3)
{
    PID_clear(&(gimbalYawCtrl.spd_pid));
    PID_clear(&(gimbalYawCtrl.agl_pid));
    PID_clear(&(gimbalPitchCtrl.spd_pid));
    PID_clear(&(gimbalPitchCtrl.spd_pid));
    
}
```

例如不知道什么原因云台不动的时候，操作手可以把遥控器左上方的拨杆拨到中间，清除云台PID值。云台就可以运动了。

原因未知。

###### PID控制器的改造

角度是有周期的。角度加减会出现超越(-PI,PI)范围，需要使用format转换到(-PI,PI)范围。而这个范围的优越性在于它的正负正好对应了最短旋转方向所需的电压。

```c
/**
 * @brief 计算转圈的PID。内部error先循环转化为(-PI,PI)范围
 * 
 * @param pid 
 * @param ref 反馈值
 * @param set 设定值
 * @return fp32 
 */
fp32 gimbal_PID_calc(pid_type_def *pid, fp32 ref, fp32 set);
```

内部计算error的时候

```c
pid->error[2] = pid->error[1];
pid->error[1] = pid->error[0];
pid->set = set;
pid->fdb = ref;
pid->error[0] = radFormat(set - ref);
```

和普通PID计算器不一样之处：计算了最短旋转方向。

###### 云台轴角度的限制

双轴云台转动时，可能会达到最大角度，撞在限位装置上。因此，需要对期望角度进行限制。另外，电机在转动过程中，由于是从遥控器和鼠标获得期望位置，而后发送到PID控制器计算差距和输出电压。然而云台旋转毕竟是一圈。如果期望角度是当前角度向逆时针旋转3π/2，结果就是顺时针π/2的角度，导致本来左转变成了右转。一个解决方法是：强制让期望位置不超过当前位置的π/2距离。

```c
// 超过最大PI/2角度时,限制幅度   //test done
    if(radFormat(c->wantedAbsoluteAngle - c ->nowAbsoluteAngle) > (PI/2))
        c->wantedAbsoluteAngle = c ->nowAbsoluteAngle + (PI/2);
    if(radFormat(c->wantedAbsoluteAngle - c ->nowAbsoluteAngle) < (-PI/2))
        c->wantedAbsoluteAngle = c ->nowAbsoluteAngle - (PI/2);
```

另外，当电机转到最大ECD位置时，期望的角度不应该再向这个方向变化。

这是一个“勉强能用”的方法。没有考虑复杂的中央为0的情况。**有时做了太多抽象，系统的性能却降低了。因此，有的地方就直接使用解决具体问题的方法就足够了。**

```c
/**
 * @brief 用ECD限制pitch角度，一定要事先确定pitch中央ECD不含0
 * 
 */
void limitAnglesSecond(void)
{
    if(radFormat(gimbalPitchCtrl.wantedAbsoluteAngle)>PITCH_TEST_RAD_MAX)
        gimbalPitchCtrl.wantedAbsoluteAngle=PITCH_TEST_RAD_MAX-0.05f;
    if(radFormat(gimbalPitchCtrl.wantedAbsoluteAngle)<PITCH_TEST_RAD_MIN)
        gimbalPitchCtrl.wantedAbsoluteAngle=PITCH_TEST_RAD_MIN+0.05f;
    
}
```



###### 模块组装和测试方法

在实现各个功能模块后，得到总的任务代码，在用它来驱动电机之前，**先测试每一个小的模块**。**有的计算函数可以先在Windows平台上编译运行**，看输入输出结果是否相符。例如

```c
/**
 * @brief 将0-8191的ECD值转化为-PI~PI的弧度值,只是映射一一过去
 * 0->-PI,8192->PI
 * 
 * @param ecd 
 * @return fp32 
 */
fp32 ECD2Rad(uint16_t ecd)  //test done
{
    return ((fp32)ecd)*(2*PI)/ECD_FULL_ROUND-PI;
}

```

可以先实现一个测试用的文件

```c
#include <stdio.h>

#define range_limit_inside(toBeLimited, range)                      \
    {                                                               \
        if ((toBeLimited) <= (range) && (toBeLimited) >= -(range))  \
        {                                                           \
            (toBeLimited) = (toBeLimited);                          \
        }                                                           \
        else if((toBeLimited)>(range))                              \
        {                                                           \
            (toBeLimited)=(range);                                  \
        }                                                           \
        else if((toBeLimited)<-(range))                                   \
        {                                                           \
            (toBeLimited)=-(range);                                 \
        }                                                           \
    }
typedef float fp32;
typedef unsigned short uint16_t;
typedef short int16_t;
#define ECD_FULL_ROUND 8192
#define PI 3.1415926535f
fp32 radFormat(fp32 rawAngle)   //test
{
    while(rawAngle>PI)
        rawAngle-=(2*PI);
    while(rawAngle<(-PI))
        rawAngle+=(2*PI);
    return rawAngle;
}
uint16_t ECDFormat(int16_t rawECD)     //test done
{
    while(rawECD<0)
        rawECD+=ECD_FULL_ROUND;
    while(rawECD>=ECD_FULL_ROUND)
        rawECD-=ECD_FULL_ROUND;
    return (uint16_t)rawECD;
}
fp32 ECD2Rad(uint16_t ecd)  //test
{
    return ((fp32)ecd)*(2*PI)/ECD_FULL_ROUND-PI;
}
int main()
{   
    uint16_t a,b;
    // while(1)
    // {
        a=9,b=8115;
        printf("a=a-b:%d\n",(uint16_t)(a-b));
        printf("a:%u,b:%u\n",a,b);
        printf("a-b:%d\n",(int16_t)a-(int16_t)b);
        printf("int16 delta:%d\n",(int16_t)a-(int16_t)b);
        printf("format result:%d\n",ECDFormat((int16_t)a-(int16_t)b));

    // }
}
```

真实的故事：用这个方法发现了一个2*PI写成了PI

###### 云台任务总结构

电机初始化、机器人模式指针初始化、控制指针初始化

不断执行：更新电机角度和角速度数据，根据机器人模式等获取控制角度，限制角度、监控圈数、计算PID电流、发送电流。

```c
void gimbal_task(void const *pvParameters)
{
    uint8_t i;
    osDelay(GIMBAL_TASK_INIT_TIME);
    initGimbalCtrls();
    robotMode=getRobotPresentMode();
    rc_p=get_remote_control_point();    //获取遥控器数据和NUC数据指针
    nuc_p=get_nuc_control_point();

    int16_t *triggerCurrentP=getTriggerCurrentP();//获取shoot_task源文件里计算的M2006的电流。
    while(1)
    {
        if(rc_p->rc.s[1]==3)
        {
            PID_clear(&(gimbalYawCtrl.spd_pid));
            PID_clear(&(gimbalYawCtrl.agl_pid));
            PID_clear(&(gimbalPitchCtrl.spd_pid));
            PID_clear(&(gimbalPitchCtrl.spd_pid));
            
        }

        for(i=0;i<2;i++)
            refreshAngleStates(gimbalCtrl[i]);   // 从传感器获得当前角度数据 //test done
        getControlAngles();                  // 从遥控器获得目标角度     //test half done
        for(i=0;i<2;i++)
        {
            monitorRounds(gimbalCtrl[i]);        // 监控转过的圈数           //test
            limitAngles(gimbalCtrl[i]);          // 限制目标角度，不超过pid范围pi/2，不超过总角度
        }
        limitAnglesSecond();    //上一个limit angle似乎没法控制当电机自己转过去时引发的角度变换。那直接把机器人当做在平地上，用ECD限制一次幅度
        calcPID();              // 总是控制角度，双环，但测试时需要
        #ifdef ZERO_CURRENT_SAFE
        CAN_cmd_gimbal(0,0,0,0);
        #else
        CAN_cmd_gimbal(gimbalYawCtrl.giveVolt,gimbalPitchCtrl.giveVolt,*triggerCurrentP,0);       // 暂时只测试云台，不测试发射 //TO DO，加上拨弹轮电流控制函数
        #endif
        osDelay(GIMBAL_TASK_CTRL_TIME);
    }
}
```

###### 不同模式下云台控制角度的计算

在不同模式切换的时候，可能会有期望量的突变，引发危险。增加模式转换时对期望量的更改。

```c
//发现在bad yaw car转到其他模式后，云台会突然转向。这是因为云台没有到程序希望的位置于是，增加一个转换过程。
    // 当上一次模式和这一次模式不同时，将希望的角度设置为当前角度。
    static enum RobotState_e lastMode=RobotState_e_Powerless;   //初始化为无力
    if(lastMode!=(*robotMode))
        gimbalYawCtrl.wantedAbsoluteAngle=gimbalYawCtrl.nowAbsoluteAngle;
    lastMode=*robotMode;
```

无力模式：直接发送零电流。使用了zeroCurrentMark，作为0电流标记。清除所有标记和目标角度。

自动模式：使用NUC传来的数据作为目标角度。操作手可以使用鼠标控制偏移角度。当取消自瞄的时候，这个角度清零。



手动模式：目标角度增量为灵敏度在时间上的积累。

```c
if(!robotIsAuto())
        {
            gimbalYawCtrl.wantedAbsoluteAngle += GIMBAL_TASK_CTRL_TIME*(yaw_channel * YAW_RC_SEN + rc_p->mouse.x * YAW_MOUSE_SEN);
            gimbalPitchCtrl.wantedAbsoluteAngle += GIMBAL_TASK_CTRL_TIME*(pitch_channel * PITCH_RC_SEN + rc_p->mouse.y * PITCH_MOUSE_SEN);
        }
```

小陀螺和普通车模式直接计算双环PID，而后发送pitch和yaw的控制电流。对于bad yaw模式，依然需要旋转。此时的云台旋转由底盘旋转代替。角度环计算出来的角速度乘上某个系数直接作用于底盘速度控制。为此，底盘云台需要通信。定义通信所用结构体。

```c
struct GimbalToChassis_s{
    int8_t effective;   //数据有效
    fp32 w;     //角速度，rad/s
};
```

```c
else if(*robotMode==RobotState_e_BadYawCar)
        {
            toChassis.effective=1;
            gimbalYawCtrl.zeroVoltMark=1;
            // 用于后续计算旋转速度
            // gimbalYawCtrl.wantedAbsoluteAngle += GIMBAL_TASK_CTRL_TIME*(yaw_channel * YAW_RC_SEN + rc_p->mouse.x * YAW_MOUSE_SEN);
            // gimbalPitchCtrl.wantedAbsoluteAngle += GIMBAL_TASK_CTRL_TIME*(pitch_channel * PITCH_RC_SEN + rc_p->mouse.y * PITCH_MOUSE_SEN);
            
        }
```



#### 底盘任务

其实有多个版本的控制代码。v15是最简单的，**抓住了最主要矛盾**。v30.10**在前者的基础上增加**了为比赛设计的模式切换以及和云台数据的通信，提升了机器人的**控制丰富性和机器人总体的稳定性**。

###### Naive底盘运动控制原理

先以v15为例，讲述机器人底盘速度计算的基本原理。我们使用的轮子叫做麦克纳姆轮，在大轮子上套上了斜向的小轮子。于是在大轮子转动的时候，小轮子会收到斜向的力。通过四个轮子的组合，可以实现机器人的四个方向平移和原地旋转，进而可以组合得到任意方向平移、一边平移一边旋转等运动状态。需要先精准定义坐标系。以机器人前进方向为x正方向，机器人左平移方向为y正方向。

v15的代码中，首先通过遥控器数据获得期望速度。这里删除了调试所用代码。事实上在编写这个版本的时候遇到了很多问题。例如遥控器通道的值，其实已经是解析好的-660~660的值。但一开始以为是0-1000左右的值，导致重复解析，机器人的轮子始终转动。使用**OLED模块输出数据来调试，发现了这个问题**。

```c
static void getRcAndCalcTotalSpeed(void)
{
    rc_deadband_limit(rc_p->rc.ch[CHASSIS_X_CHANNEL],vx_channel,CHASSIS_RC_DEADLINE);
    rc_deadband_limit(rc_p->rc.ch[CHASSIS_Y_CHANNEL],vy_channel,CHASSIS_RC_DEADLINE);
    rc_deadband_limit(rc_p->rc.ch[CHASSIS_W_CHANNEL],w_channel,CHASSIS_RC_DEADLINE);
    
    vx=vx_channel*CHASSIS_VX_RC_SEN;
    vy=vy_channel*CHASSIS_VY_RC_SEN;
    w=w_channel*CHASSIS_WZ_RC_SEN;
}
```

计算轮子期望的速度（根据麦克纳姆轮的运动特征和计算公式）

```c
static void calcNeededMotorSpeed(void)
{
    wantedVMotor[0]=-vx+vy-w;
    wantedVMotor[1]=vx+vy-w;
    wantedVMotor[2]=vx-vy-w;
    wantedVMotor[3]=-vx-vy-w;
}
```

更新轮子当前的速度

```c
static void getMotorSpeed(void)
{
    uint8_t i;
    for(i=0;i<4;i++)
    {
        presentVMotor[i]=get_chassis_motor_measure_point(i)->speed_rpm*M3508_MOTOR_RPM_TO_VECTOR;
    }
}
```

放入PID控制器计算速度

```c
static void calcGiveCurrent(void)
{
    int i;
    for(i=0;i<4;i++)
        PID_calc(&motorPIDs[i],presentVMotor[i],wantedVMotor[i]);
    for(i=0;i<4;i++)
        giveCurrent[i]=motorPIDs[i].out;   
}
```

发送控制电流

```c
CAN_cmd_chassis(giveCurrent[0], giveCurrent[1], giveCurrent[2], giveCurrent[3]);
```

完整流程：首先初始化PID控制器和遥控器数据指针。在while(1)循环里，不断更新当前电机转速和期望转速，放入PID控制器计算发送电流。

```c
osDelay(CHASSIS_TASK_INIT_TIME);
initPIDs();
rc_p=get_remote_control_point(); 
while(1)
    {
        getRcAndCalcTotalSpeed();
        calcNeededMotorSpeed();
        getMotorSpeed();
        calcGiveCurrent();
        CAN_cmd_chassis(giveCurrent[0], giveCurrent[1], giveCurrent[2], giveCurrent[3]);
        // CAN_cmd_chassis(400,1000,100,100);
        osDelay(CHASSIS_CONTROL_TIME_MS);
    }
```

###### 为比赛设计的底盘控制过程

总体思路是根据机器人总状态设置底盘分状态。**一定要先明确设计机器人总体的状态！详细到操控的按键和特点！请参考后面”操作手指南“部分**而后根据底盘的状态或者总状态根据约定解析机器人底盘所需的速度，包括旋转和平移。而后计算四个轮子所需速度，送到PID环计算电流，发送到电机。

```c
while(1)
{
    setChassisMode();
    analyseTotalControl();
    refreshECD();
    calcWheelVelocityInChassisAxis();
    calcGiveCurrent();
    if(zeroCurrentMark) 
        CAN_cmd_chassis(0,0,0,0);       //发送零电流
    else
        CAN_cmd_chassis(driveMotor[0].giveCurrent,driveMotor[1].giveCurrent,
            driveMotor[2].giveCurrent,driveMotor[3].giveCurrent);   //正常控制电机


    osDelay(CHASSIS_CONTROL_TIME_MS);
}
```

首先设置底盘模式。曾经，底盘有跟随云台、不跟随云台、无力等模式，但不方便管理。后来，直接根据机器人总状态和相应协议解析机器人的运动状态。于是，底盘模式设置函数只需控制0电流标志的。

```c
static void setChassisMode(void)
{
    zeroCurrentMark=0;
    if(RobotState_e_Powerless== *robotMode)
        zeroCurrentMark=1;
}

```

在解析机器人目标速度之前，需要定义一些常量。包括按键定义、按键按下时的速度、一些灵敏度系数等。通过实验确定合适的取值。

以下是三种控制模式的切换定义，在naive_chassis_task.c中。

实际设计的时候，先在纸上画出了所有的键位分配，考虑操作手的操作方便性。目前所有的控制没有组合键。键盘上还有Q 和R 没有使用。**未来可以增加开启超声避障和关闭超声避障**。

```c
//*************************按键定义********************//
// 机器人有四种模式。无力、普通车、卡yaw坏车、（准）小陀螺车（根据机械定义自动判断是否变化方向）。
//按键定义
#define HANDLE_LEFT_LR 2    //遥控器左边摇杆的左右方向  left right
#define HANDLE_LEFT_BF 3    //遥控器左边摇杆的前后方向  back forth
#define HANDLE_RIGHT_LR 0    //遥控器右边摇杆的左右方向  left right
#define HANDLE_RIGHT_BF 1    //遥控器右边摇杆的前后方向  back forth

//普通车模式    common car 按C或者遥控器右拨杆上方开启，（全能坦克）
//平移控制的坐标系为底盘坐标系
#define COMMON_FORTH            KEY_PRESSED_OFFSET_E    //前进
#define COMMON_BACK             KEY_PRESSED_OFFSET_D    //后退
#define COMMON_LEFT_ROTATE      KEY_PRESSED_OFFSET_S    //左转
#define COMMON_RIGHT_ROTATE     KEY_PRESSED_OFFSET_F    //右转
#define COMMON_LEFT_MOVE        KEY_PRESSED_OFFSET_A    //左平移
#define COMMON_RIGHT_MOVE       KEY_PRESSED_OFFSET_G    //右平移
//而遥控器左摇杆控制前后平移和左右旋转
#define COMMON_BF_RC            HANDLE_LEFT_BF      //前进,后退
#define COMMON_LR_ROTATE_RC     HANDLE_LEFT_LR      //左转,右转

//小陀螺模式    spinner，就像一个旋转的陀螺v，所以按v进入小陀螺模式。或者遥控器右拨杆在中间进入
//平移控制的坐标系为云台坐标系
#define SPINNER_FORTH            KEY_PRESSED_OFFSET_W    //前进
#define SPINNER_BACK             KEY_PRESSED_OFFSET_S    //后退
#define SPINNER_LEFT_MOVE        KEY_PRESSED_OFFSET_A    //左平移
#define SPINNER_RIGHT_MOVE       KEY_PRESSED_OFFSET_D    //右平移
//遥控器左摇杆控制前后平移和左右平移
#define SPINNER_BF_RC            HANDLE_LEFT_BF      //前进,后退
#define SPINNER_LR_MOVE_RC       HANDLE_LEFT_LR      //左转,右转


//卡yaw坏车模式    bad yaw，首字母B，所以按B进入卡yaw坏车模式。或者遥控器右拨杆在下进入
//此时，云台yaw相对于底盘不转动，所有云台目标转动量（包括自瞄）输出到底盘
//平移控制的坐标系为云台坐标系
#define BAD_YAW_FORTH            KEY_PRESSED_OFFSET_W    //前进
#define BAD_YAW_BACK             KEY_PRESSED_OFFSET_S    //后退
#define BAD_YAW_LEFT_MOVE        KEY_PRESSED_OFFSET_A    //左平移
#define BAD_YAW_RIGHT_MOVE       KEY_PRESSED_OFFSET_D    //右平移

#define BAD_YAW_BF_RC            HANDLE_LEFT_BF      //前进,后退
#define BAD_YAW_LR_MOVE_RC       HANDLE_LEFT_LR      //左转,右转

///////////////////////////////////////////////////////////////////////
```

根据机器人的控制模式，有如下的速度解析。每一种操作都存在遥控器和键盘共同控制的情形。直接将两种控制方式得到的速度相加，能够起到控制的作用。

为了控制速度，使用一个速度控制结构体。由于控制量存在底盘坐标系和云台坐标系，使用一个变量标记坐标系的选择，使用三个速度变量，标记两个正交方向的平移速度和旋转速度。在不同模式下选择不同坐标系，从而计算电机速度。

```c
// 坐标系
enum MovingAxis_e{
    MovingAxis_e_GimbalAxis,
    MovingAxis_e_ChassisAxis,
};

//机器人控制量
struct RobotControl_s{
    fp32 vx,vy,w;
    enum MovingAxis_e axis;
};
```

根据不同模式、按键按下的情况、遥控器摇杆的值，在这个控制结构体中设置速度和坐标系。相比于v15，v30.10多了键盘控制和不同的模式选择。

在卡yaw模式下，云台yaw并不转动，机器人的旋转角速度来源于云台任务中更新的角速度。并不需要精确的速度计算，调试参数，编译后重新上传，机器人运动合适就足够了。

小陀螺运动模式下，会判断当前旋转的圈数，当圈数达到最大圈数时，让机器人底盘反向转动。

```C
static void analyseTotalControl(void)    //通过遥控器和键盘参数设置速度。当键盘输出量为0时，通过遥控器摇杆确定速度。
{
    // int keyBoardMove=0;
    //注意建系的方向
    robotTotalSpeedControl.axis=MovingAxis_e_GimbalAxis;    //默认云台坐标系，有助于操作手的控制
    robotTotalSpeedControl.vx=0;robotTotalSpeedControl.vy=0;robotTotalSpeedControl.w=0;
    
    if(RobotState_e_Powerless==*robotMode)
    {
        return;
    }
    else if(RobotState_e_CommonCar==*robotMode)
    {
        //底盘坐标系
        robotTotalSpeedControl.axis=MovingAxis_e_ChassisAxis;
        if(rc_p->key.v & COMMON_FORTH)  //前
            robotTotalSpeedControl.vx+=KEYBOARD_CONTROL_ROBOT_SPEED_X;
        if(rc_p->key.v & COMMON_BACK)  //后
            robotTotalSpeedControl.vx-=KEYBOARD_CONTROL_ROBOT_SPEED_X;
        if(rc_p->key.v & COMMON_LEFT_MOVE)  //左
            robotTotalSpeedControl.vy+=KEYBOARD_CONTROL_ROBOT_SPEED_Y;
        if(rc_p->key.v & COMMON_RIGHT_MOVE)  //右
            robotTotalSpeedControl.vy-=KEYBOARD_CONTROL_ROBOT_SPEED_Y;
        if(rc_p->key.v & COMMON_LEFT_ROTATE)    //左旋 从上向下看为逆时针
            robotTotalSpeedControl.w+=KEYBOARD_CONTROL_ROBOT_SPEED_W;
        if(rc_p->key.v & COMMON_RIGHT_ROTATE)   //右旋
            robotTotalSpeedControl.w-=KEYBOARD_CONTROL_ROBOT_SPEED_W;

        rc_deadband_limit(rc_p->rc.ch[COMMON_BF_RC],vx_channel,CHASSIS_RC_DEADLINE);
        rc_deadband_limit(rc_p->rc.ch[COMMON_LR_ROTATE_RC],w_channel,CHASSIS_RC_DEADLINE);
        robotTotalSpeedControl.vx +=vx_channel*CHASSIS_VX_RC_SEN;
        robotTotalSpeedControl.w +=w_channel*CHASSIS_WZ_RC_SEN;

    }
    else if(RobotState_e_BadYawCar==*robotMode)
    {
        //云台坐标系
        robotTotalSpeedControl.axis=MovingAxis_e_GimbalAxis;

        if(rc_p->key.v & BAD_YAW_FORTH)  //前
            robotTotalSpeedControl.vx+=KEYBOARD_CONTROL_ROBOT_SPEED_X;
        if(rc_p->key.v & BAD_YAW_BACK)  //后
            robotTotalSpeedControl.vx-=KEYBOARD_CONTROL_ROBOT_SPEED_X;
        if(rc_p->key.v & BAD_YAW_LEFT_MOVE)  //左
            robotTotalSpeedControl.vy+=KEYBOARD_CONTROL_ROBOT_SPEED_Y;
        if(rc_p->key.v & BAD_YAW_RIGHT_MOVE)  //右
            robotTotalSpeedControl.vy-=KEYBOARD_CONTROL_ROBOT_SPEED_Y;
        rc_deadband_limit(rc_p->rc.ch[BAD_YAW_BF_RC],vx_channel,CHASSIS_RC_DEADLINE);
        rc_deadband_limit(rc_p->rc.ch[BAD_YAW_LR_MOVE_RC],vy_channel,CHASSIS_RC_DEADLINE);
        robotTotalSpeedControl.vx += vx_channel*CHASSIS_VX_RC_SEN;
        robotTotalSpeedControl.vy += vy_channel*CHASSIS_VY_RC_SEN;
        if(badYawData->effective)
            robotTotalSpeedControl.w += badYawData->w *BAD_YAW_DATA_ROTATE_COEF;
    }
    else if(RobotState_e_Spinner==*robotMode)
    {
        //云台坐标系
        robotTotalSpeedControl.axis=MovingAxis_e_GimbalAxis;
        if(rc_p->key.v & SPINNER_FORTH)  //前
            robotTotalSpeedControl.vx+=KEYBOARD_CONTROL_ROBOT_SPEED_X;
        if(rc_p->key.v & SPINNER_BACK)  //后
            robotTotalSpeedControl.vx-=KEYBOARD_CONTROL_ROBOT_SPEED_X;
        if(rc_p->key.v & SPINNER_LEFT_MOVE)  //左
            robotTotalSpeedControl.vy+=KEYBOARD_CONTROL_ROBOT_SPEED_Y;
        if(rc_p->key.v & SPINNER_RIGHT_MOVE)  //右
            robotTotalSpeedControl.vy-=KEYBOARD_CONTROL_ROBOT_SPEED_Y;
        rc_deadband_limit(rc_p->rc.ch[SPINNER_BF_RC],vx_channel,CHASSIS_RC_DEADLINE);
        rc_deadband_limit(rc_p->rc.ch[SPINNER_LR_MOVE_RC],vy_channel,CHASSIS_RC_DEADLINE);
        robotTotalSpeedControl.vx += vx_channel*CHASSIS_VX_RC_SEN;
        robotTotalSpeedControl.vy += vy_channel*CHASSIS_VY_RC_SEN;
        //内置旋转速度控制程序
        //最简单的，单级spinner 速度
        // 从云台控制那里获取云台相对于底盘转过的圈数，云台逆时针转为正圈数。若到达顶峰，则让底盘也逆时针转动
        static fp32 nowSpinnerW=SPINNER_W; //初始化底盘逆时针旋转 (奇怪，一次弄错，后面得跟着反过来)
        if(*gimbalRounds>=SPINNER_MAX_ROUNDS)   //云台逆时针转多了
            nowSpinnerW=SPINNER_W;  //底盘逆时针跟上
        else if((*gimbalRounds)<=-SPINNER_MAX_ROUNDS) //云台顺时针转多了
            nowSpinnerW=-SPINNER_W;  //底盘顺时针跟上
        robotTotalSpeedControl.w=nowSpinnerW;
    }    
}

```

而后根据速度控制结构体计算四个轮子的转速。首先变换到相应坐标系中的轮子速度，而后根据是否存在坐标系的变换需求选择不同的计算方法。机器人运动，轮子速度是在底盘坐标系中的，而为了操作手的视角方便，有时会使用云台坐标系涉及坐标系变换的数学公式和arm_math库函数的使用。需要复制arm_math库到工程中，链接时才能找到三角函数arm_sin_fp32和arm_cos_fp32。

坐标系变换的公式写出来可能是错误的。这时，可以使用简单的特殊情况验证公式是否正确，此时sin和cos已经取0或±1。例如，当云台逆时针转向90°时，云台坐标系中的前进实际上对应底盘的y方向正向运动。用另一个方向上的情况，可以验证其它项是否正确。

```c
static void calcWheelVelocityInChassisAxis(void)   //将控制量中的坐标系速度转化为底盘坐标系的速度，并计算轮子转动速度
{
    fp32 sin_yaw,cos_yaw;
    fp32 vx,vy,w;
    sin_yaw=arm_sin_f32(someAngle.gimbalAngleFromChassis);
    cos_yaw=arm_cos_f32(someAngle.gimbalAngleFromChassis);
    w=robotTotalSpeedControl.w;
    // robotTotalSpeedControl.axis=MovingAxis_e_GimbalAxis;
    if(robotTotalSpeedControl.axis==MovingAxis_e_GimbalAxis)
    {
        //将云台坐标系速度转化为底盘坐标系速度。坐标系变换
        vx=cos_yaw*robotTotalSpeedControl.vx-sin_yaw*robotTotalSpeedControl.vy;
        vy=sin_yaw*robotTotalSpeedControl.vx+cos_yaw*robotTotalSpeedControl.vy;
        
    }
    else if(robotTotalSpeedControl.axis==MovingAxis_e_ChassisAxis)
    {
        vx=robotTotalSpeedControl.vx;
        vy=robotTotalSpeedControl.vy;
    }
    driveMotor[0].wantedMotorSpeed=-vx-vy-w;    //麦轮速度计算公式
    driveMotor[1].wantedMotorSpeed=vx-vy-w;
    driveMotor[2].wantedMotorSpeed=vx+vy-w;
    driveMotor[3].wantedMotorSpeed=-vx+vy-w;

    #ifdef OLED_DEBUG_CHASSIS_TASK_ON
    debug_vx=vx;
    debug_vy=vy;
    debug_w=w;
    #endif
}
```

获取云台电机的ECD角度，用来实现圈数监测，实现准小陀螺运动。

```c
static void refreshECD(void)   //更新当前云台yawECD值和弧度制的值，实现云台坐标系控制以及小陀螺
{
    someAngle.nowGimbalYawECD=get_yaw_gimbal_motor_measure_point()->ecd;
    someAngle.gimbalAngleFromChassis=(someAngle.nowGimbalYawECD-someAngle.initGimbalYawECD)*2*PI/ECD_FULL_ROUND;
}
```

获得期望和实际轮子转速后，在PID控制器中计算控制电流

```c
static void calcGiveCurrent(void) //pid 计算电流
{
    uint8_t i;
    for(i=0;i<4;i++)
    {
        driveMotor[i].presentMotorSpeed=get_chassis_motor_measure_point(i)->speed_rpm*M3508_MOTOR_RPM_TO_VECTOR;    //获取电机转速
        PID_calc(&(driveMotor[i].vpid),driveMotor[i].presentMotorSpeed,driveMotor[i].wantedMotorSpeed);   //pid计算
        driveMotor[i].giveCurrent=driveMotor[i].vpid.out;    //pid的输出就是驱动电流
    }
}
```

使用结构体变量实现电机电流和速度数据的管理。

```c
//底盘电机控制
struct MotorControl_s{
    pid_type_def    vpid;
    fp32            presentMotorSpeed;
    fp32            wantedMotorSpeed;
    int16_t         giveCurrent;
};

```



#### 发射任务

机器人通过发射荧光弹击打对方装甲板得分。按照规则击打大能量机关。击打高处的哨兵装甲板开启对方基地护甲。击打基地得分。目前在场上，机器人最重要的是射击的精准度、快速程度、自动程度。需要考虑云台控制精准度、弹道弯曲补偿、发射响应速度等问题、视觉识别的精准度。

目前云台的角度控制精度有限。原因之一是云台yaw太卡、控制方法不够优秀。弹道弯曲未通过实验测定。需要和视觉组通力合作，完善通信测试，把工作连接起来。相关工作请参考视觉组或者电控组群内《serialOnComputer2022年2月14日》《视觉电控接口for第一阶段简易自瞄2022年2月14日》。

**这个比赛很重要的一个目标就是射击的精准度、通过机器人视觉自动规划和控制。**如果机器人还能根据对方发射的方向自动躲避就会更加智能了。在完成基础的架构后，需要做最重要的事。

###### 发射的基本控制方法

根据操作手或者NUC的指令自动控制电机转动，将荧光弹从弹舱拨动到发射槽内，到达摩擦轮旁被摩擦轮加速发射出去。

发射涉及两种电机。一个拨弹轮在弹舱内，起到输送荧光弹的作用；两个摩擦轮（摩擦力很大）的驱动电机在炮口位置。荧光弹的大小略小于弹性摩擦轮之间的间隙。为了发射子弹，需要首先开启摩擦轮，待摩擦轮速度增加到很高时，让拨弹轮转动，将子弹推到摩擦轮前，发射出去。如果摩擦轮未转动，而拨弹轮却将子弹推到了摩擦轮前，就会导致卡弹。

发射槽的长度过长，导致有子弹存储于摩擦轮前方。当机器人pitch下落时，存储在槽内的子弹会掉出去。

我们可以在发射槽位置增加一个簧片和一些3D打印件......（见待完成的任务）

v15，naive的发射任务总工作流程。这个版本只能手动直接控制摩擦轮开启和拨弹轮转动。唯一的智能是：在摩擦轮关闭时，拨弹轮一定会被关闭。

程序设计思路：用遥控器的拨杆控制摩擦轮开启和关闭。当遥控器左上拨杆拨到下的位置时，开启拨弹轮供弹。因此，只需要使用两个标记电机是否开启的变量，根据这两个变量是0还是1决定摩擦轮和拨弹轮的目标速度。而后像控制底盘电机转速一样用PID算法控制摩擦轮和拨弹轮的转动。

程序如下：先初始化PID，而后根据指令判断电机是否开启，而后计算所需速度、控制电流，发送控制电流。

```c
void shoot_task(void)
{
    osDelay(SHOOT_TASK_INIT_TIME);
    initShootPIDs();
    while(1)
    {
        processMotorOnOff();
        calcNeededShootMotorSpeed();
        getShootMotorSpeed();
        calcGiveCurrent();
        CAN_cmd_shoot(giveShootCurrent[0], giveShootCurrent[1]);

        osDelay(SHOOT_CTRL_TIME);
    }
}
```

我们使用的是M3508电机作为摩擦轮电机，挂载在云台can总线上，ID为1和2。官步开源代码并不是用M3508实现的摩擦轮电机控制，因此CAN_receive文件和官步的CAN_receive文件不一样。根据《电控方案设计v1.0-2022年1月25日》的can信道分配，使用 CAN_cmd_shoot包装了can发送电流的过程。而根据设计和can报文的分配，拨弹轮的电流和云台pitch、yaw电机的电流处于同一数据帧，因此拨弹轮的电流需要由云台控制任务一同发送。任务分配是：电流计算由shoot_task完成，而电流发送由云台任务完成。

处理发射相关的电机的开启和关闭的函数。设计的是：左上拨杆移到上，而后移到下， 开启摩擦轮或者关闭摩擦轮。移到下，在摩擦轮开启的前提下，拨弹轮会转动。

思路和嵌入式程序对按键的处理类似。

```c
static void processMotorOnOff(void)
{
    rc_p=get_remote_control_point();
    static int up=0;
    if(switch_is_up(rc_p->rc.s[SHOOT_MODE_CHANNEL]))
    {
        up=1;
        // mid=0;
        // down=0;
    }
    else if(switch_is_mid(rc_p->rc.s[SHOOT_MODE_CHANNEL]))
    {
        // mid=1;
        if(up==1)
        {
            if(fricOn)
            {
                fricOn=0;
                triggerOn=0;
            }    
            else
                fricOn=1;
            up=0;
        }
        triggerOn=0;
    }
    else if(switch_is_down(rc_p->rc.s[SHOOT_MODE_CHANNEL]))
    {
        // down=1;
        if(fricOn)
            triggerOn=1;
        else
            triggerOn=0;
    }
}
```

而后有了这两个是否开启的标记后，设定电机的旋转速度。共有三个电机的旋转速度需要设置：两个摩擦轮，一个拨弹轮。

```c
static void calcNeededShootMotorSpeed(void)
{
    if(fricOn)
    {
        wantedVShootMotor[0]=-SHOOT_SPEED_LIMIT;//实验测试转动方向。反过来可以实验卡弹时的退弹
        wantedVShootMotor[1]=SHOOT_SPEED_LIMIT;
    }
    else
    {
        wantedVShootMotor[0]=0;
        wantedVShootMotor[1]=0;
    }
    if(triggerOn)
        wantedVTriggerMotor=-SHOOT_TRIGGER_SPEED_LIMIT;
    else
        wantedVTriggerMotor=0;
}
```

和普通PID控制一样，获取当前速度，用PID控制器计算控制电流。从can数据区内获取电机转速，而后乘以一个系数作为电机当前速度。

```c
static void getShootMotorSpeed(void)
{
    uint8_t i;
    for(i=0;i<2;i++)
    {
        presentVShootMotor[i]=get_shoot_motor_measure_point(i)->speed_rpm*SHOOT_M3508_MOTOR_RPM_TO_VECTOR;
    }
    presentVTriggerMotor=get_trigger_motor_measure_point()->speed_rpm*SHOOT_M2006_MOTOR_RPM_TO_VECTOR;
}
```

PID计算。而后将输出放入电流变量中。摩擦轮的电流在shoot_task中直接发送。拨弹轮的电流传输到云台后发送。

```c
static void calcGiveCurrent(void)
{
    int i;
    for(i=0;i<2;i++)
        PID_calc(&shootMotorPIDs[i],presentVShootMotor[i],wantedVShootMotor[i]);
    for(i=0;i<2;i++)
        giveShootCurrent[i]=shootMotorPIDs[i].out;
    PID_calc(&triggerMotorPID,presentVTriggerMotor,wantedVTriggerMotor);
    giveTriggerCurrent=triggerMotorPID.out;
}
```

很重要的是PID取值，积分项系数需为0。否则在让目标速度为0的时候，摩擦轮会继续转动。这一个细节在v30.10才得到完善。

提供给云台任务调用的数据

```c
int16_t * getTriggerCurrentP(void)
{
    return &giveTriggerCurrent;
}
```

###### 单发控制方案——用程序的智能弥补硬件的缺失

上述控制方法显然无法用于比赛。它无法用鼠标控制发射。它无法控制单发。它也无法控制射速、射频。

单发看起来需要一个安装在摩擦轮前的微动开关，检测有无子弹通过。但是后来用在云台控制任务中发明的圈数检测算法——里程碑栈法实现了单发。而后通过实验测量圈数、修改程序优化了单发的控制能力，开学后，期望在发射管道中增加一个简易限位装置（亦即上文所述”增加一个弹簧片“），进一步优化单发的性能。

v30.10里，可以使用宏定义定义最高射频。射速需要未来做实验测定。

实际在开发v30.9的新射击代码时，首先在纸上设计了所需的控制方法。遥控器离线时关闭发射机构所有相关电机，Shift键开启摩擦轮。遥控器左上拨杆上拨后移到中间，可以开启或关闭摩擦轮。当遥控器左拨杆移到中间时，允许鼠标控制发射。鼠标左键按下后立刻抬起，发射一颗子弹；左键按住不放，连发。鼠标右键按下不放：允许NUC控制发射单发或者连发。当然，遥控器左上拨杆也可控制发射。置于下端，而后立刻置于中间，发射一颗子弹；置于下端不停，连发。设计原因如下：虽然在比赛过程中，不需要关闭摩擦轮，键盘开启和关闭按钮似乎多余，但是实际比赛过程中，操作手距离机器人很远，看不到摩擦轮是否开启。为了能够确保摩擦轮开启，设计一个shift键，只能发送开启摩擦轮的命令。而不在键盘上留关闭摩擦轮的按键，目的是防止操作手误触导致摩擦轮关闭卡弹。

至于避免摩擦轮意外关闭导致卡弹，还用**状态机模型**和**命令缓冲机制优化了发射的控制流程**。在拨弹轮转动、亦即在发射一颗子弹的过程中，不允许摩擦轮突然关闭。而在拨弹轮停止时，才允许摩擦轮关闭。考虑到NUC或者操作手可能会给予错误命令，需要命令缓冲机制，在拨弹轮处于停止状态时，才接受关闭摩擦轮的指令。另外，在摩擦轮开启的时候，才允许拨弹轮发射子弹状态。

连发和单发如何切换？使用状态机模型。

<img src="D:/大学课外/RM2022/电控/notes/电控代码设计说明/image/trigger状态机.png" alt="trigger状态机" style="zoom:50%;" />



拨弹轮电机存在三种模式。当单发指令来到时，切换到单发状态。单发完成后，进入停止状态。当连发指令来到时，根据射频和上次发射时刻等待进入单发模式的时机，时机到了，更新上次发射时间，立刻进入单发模式。

单发的控制方法：让电机转动PI/4的角度。原因是拨弹盘上有八个格子。通过监控减速电机减速前的电机编码值变化，结合之前在云台和底盘控制任务中提出的里程碑栈法，实现圈数检测。但是在实际测试的时候，圈数检测算法似乎失效了。电机高速转动的时候，圈数检测值并不正确，缓慢旋转是负的圈数，但加快速度，圈数不变了，甚至出现了正的圈数，有时还会上下拨动。怀疑是采样精度不够，在freertos中单独新建了一个拨弹轮电机ECD圈数监控任务，每1ms读取一次ECD值，但是效果并不好。无法使用freertos的软件定时器实现更加高的采样频率，似乎无解了。但后来思考出原因，可能是can总线收到的数据、电调在电机上的采样精度导致的ECD范围不够连续和精确。**于是直接修改threshold，从200修改成了2000**.让这个范围足够大而又不相互重叠。避免了ECD采样不够、范围不连续导致的错过里程碑的情况。

```c
//*************************里程碑栈法的控制参数***********//
#define MILESTONE_NEAR_THRESHHOLD 2000
#define MILESTONE_NUMBER 3

```

重新实验，得到的圈数检测算法运行效果非常理想。轻轻一转，就得到了很多圈。（OLED实时显示圈数。在最后一个任务的编写时，终于找到了最简单的调试控制方法，下面介绍一下。）

在射击任务中，包含OLED头文件，而后创建打印函数

```c
///////////////////////////
void OLED_Shoot(void)
{
    OLED_printf(0,0,"t%d,presl:%d,swh:%d,Ins:fric=%d,one=%d,mul=%d,press:%d,trgMd:%d,fricOn:%d,trgOn:%d,round:%d,cur:%d",HAL_GetTick(), rc_p->mouse.press_l, rc_p->rc.s[SHOOT_MODE_CHANNEL],insBuff.turnOnFric,insBuff.shootOne,insBuff.shootMulti,pressTimeDebug,triggerMode,fricOn,triggerOn,triggerCtrl.nowRounds,giveShootCurrent[0]);
}

///////////////////////////
```

转移到OLED任务中，声明这个函数

```c
void OLED_Shoot(void);
```

在OLED任务的while(1)循环内，增加如下代码

```c
#ifdef SHOW_SHOOT_DATA
                OLED_Shoot();
#endif
```

那么在有SHOW_SHOOT_DATA的定义时，OLED任务会以任务中定义的频率打印并刷新显示内存。并且OLED_printf函数能够自动换行。能很方便地直接在发射任务文件中增加要显示的函数，而不用切换到OLED任务模块中重新定义变量和打印函数，相比于以前的方法非常方便。

为什么不适用调试器呢？因为调试器可能出错，它出错，可能把不执行的代码当成要执行的代码。调试器出的错和编译器出的错，说不定错到一起去了。调试器很可能把错的说成对的。而OLED模块作为程序运行时实时伴随的器件，真正反映了程序运行过程。如果它出错，不会影响具体的程序运行过程。也不会把错的说成对的。它几乎只可能把对的说成错的。

回到发射任务的设计上。单发是转某个圈数，连发是转多个某个圈数。使用缓冲命令方式减小卡弹风险。在状态机模型里，关键是每一个状态的目标，在状态切换时的操作。只对trigger电机使用状态机模型，这已经足够实现复杂的控制流程了。而总的发射并不需要状态机模型，因为它足够简单，直接照搬v15的on off 标识就足够了。首先在纸上写出所有状态（稍后将所有电控设计手稿电子化存档），而后brainstorm想清楚每一个细节。状态的目标如下：（假定电机未减速的轴转4圈发送一个子弹）

stop状态：控制电机不转动

shoot_one状态：让电机全速转动，监控让电机圈数上升（或者下降）。当和0差距大于等于4时，ECD圈数记录清零，进入stop状态。

shoot_multi状态：初始化时刻，当当前时间超过上次shoot_multi的时刻 1000/shoot_freqency时（也就是一定射频下的发射时间间隔，单位ms），进入shoot_one状态，否则呆在shoot_multi状态。此状态控制电机不动。

一个任务中，while(1)循环中的代码会不断执行，因此函数内保存状态的变量需要为静态变量，保证留存上一次的值。

设计控制流程的时候，对控制进行分层。任务死循环内有7个控制层。

<img src="D:/大学课外/RM2022/电控/notes/电控代码设计说明/image/shoot分层控制.png" alt="shoot分层控制" style="zoom:50%;" />

其中命令缓冲原样接收操作手和NUC的指令，不管是否符合控制逻辑或者安全。而后在摩擦轮状态切换中，根据当前摩擦轮开启状态等，丢弃或者接受或者暂时忽略某些命令，而后根据安全策略控制拨弹轮状态，再根据每个状态的目标计算目标速度。监控ECD圈数可以放在任何位置，这是因为程序执行很快，1s能执行近1000次。（但是某些任务就不是了，在同一个任务中有执行的顺序，因为在任务暂停之前发送了控制电流，暂停期间根据这个电流工作，所以发送的是什么以及按照什么发送的至关重要。）监控圈数事实上作为单独的一个任务，有高优先级，执行也频繁。

总控制流程如下。初始化PID、控制指针、机器人总状态指针、为了实现圈数检测而使用的算法依赖的初始电机ECD编码值和ECDFormat函数等。在循环里，根据7个控制层次，不断执行控制任务。

```c
void shoot_task(void const *pvParameters)
{
    osDelay(SHOOT_TASK_INIT_TIME);
    initShootPIDs();    //初始化PID
    initTriggerECDRoundsMonitor();  //初始化拨弹轮圈数监控
    initShootModes();   //初始化发射状态
    // initWantedSpeed();  //初始化电机速度和电流 全局变量自己就是0；
    robotMode=getRobotPresentMode();
    rc_p=get_remote_control_point();    //获取遥控器数据和NUC数据指针
    nuc_p=get_nuc_control_point();
    robotMode=getRobotPresentMode();
    // triggerMonitorSubOn=1;
    while(1)
    {
        getInstructionAndBuff();    //获取指令并缓冲
        fricModeChange();           //摩擦轮状态改变
        //若摩擦轮关闭状态，则清楚单发和连发指令

        triggerModeChange();        //拨弹轮状态转变
        setSpeedByMode();
        // monitorTriggerECDRound();        //监控拨弹轮ECD圈数
        getShootMotorSpeed();
        calcGiveCurrent();                   //计算PID
                                    //发送控制电流
        #ifdef ZERO_CURRENT_SAFE
        zeroCurrentMark=1;
        #endif
        
        if(zeroCurrentMark)
        {
            CAN_cmd_shoot(0,0);
            giveTriggerCurrent=0;
        }
        else
            CAN_cmd_shoot(giveShootCurrent[0], giveShootCurrent[1]);
        
        
        osDelay(SHOOT_CTRL_TIME);
    }
}
```

当机器人处于无力模式、遥控器掉线、NUC掉线等以外情况时，清除发射命令，让电机发送0电流。

用户UI层，亦即命令缓冲层，根据协议实现了遥控器和键盘数据解析。未来若添加其他的控制模式，也可仅仅在UI层修改发射定义。

这里，长按是通过时间判断的。宏定义中有对长时间的定义，可以根据操作手的习惯修改时间。

```c
#define PRESS_LONG_TIME     700    //长时间按住的定义为700ms，700个时钟周期
```

解析过程涉及较复杂的逻辑。实际编写和调试的过程中，使用了OLED模块输出所有变量的值。调试时，开启0电流安全模式，注释掉所有的其他模块，看每一个值是否按照预期变化。如果不对，则思考、修改，重新编译下载，最终达到了预期的解析形式。

```c
//暂未添加NUC控制发射
static void getInstructionAndBuff(void)
{
    static uint32_t pressTime=0;
    static uint8_t up=0,down=0;
    zeroCurrentMark=0;
    if(toe_is_error(DBUS_TOE))
    {
        zeroCurrentMark=1;
        triggerOn=0;
        fricOn=0;
        triggerMode=TriggerMode_e_Stop;
        insBuff.turnOnFric=0;
        insBuff.shootOne=0;
        insBuff.shootMulti=0;
    }
        
    //通过按键开启摩擦轮（也许用处并不大，有了遥控器的就足够了，但还是用来确保开启了摩擦轮吧）
    if(rc_p->key.v & KEY_FRIC_ON)
        insBuff.turnOnFric=1;       //想要开启摩擦轮
    //当遥控器右拨杆指向中央的时候，允许鼠标操控
    if(switch_is_mid(rc_p->rc.s[SHOOT_MODE_CHANNEL]))
    {
        if(rc_p->mouse.press_l) //按下左键
        {
            if(pressTime<PRESS_LONG_TIME)
                pressTime+=SHOOT_CTRL_TIME;
            else    //已经按了足够长的时间了，可以不用再增加了，
            {
                insBuff.shootMulti=1;
            }
        }
        else    //左键抬起
        {
            if(pressTime<PRESS_LONG_TIME)   //拨下并很快抬起，发射一颗
                if(pressTime>0)
                {
                    insBuff.shootOne=1; 
                }
            pressTime=0;
            insBuff.shootMulti=0;
        }
    }

    if(switch_is_up(rc_p->rc.s[SHOOT_MODE_CHANNEL]))
    {
        up=1;
    }
    else if(switch_is_mid(rc_p->rc.s[SHOOT_MODE_CHANNEL]))
    {
        //通过上拨和下拨，实现摩擦轮状态的控制
        if(up==1)   // 从上到中 下拨
        {
            if(fricOn)
            {
                // fricOn=0;
                // triggerOn=0;
                //为了防止卡弹，使用缓冲指令设计。当拨弹轮停止时才能关闭摩擦轮。
                insBuff.shootMulti=0;
                insBuff.shootOne=0;
                insBuff.turnOnFric=0;   //，希望关闭摩擦轮
            }    
            else
            {
                // fricOn=1;        
                insBuff.turnOnFric=1;   //希望开启摩擦轮
            }
            up=0;
        }
        if(down==1)  // 刚刚是下方，从下到中的上拨
        {
            insBuff.shootMulti=0;   //停止连发
            if(pressTime<PRESS_LONG_TIME)   //拨下并很快抬起，发射一颗
                if(pressTime>0)
                {
                    insBuff.shootOne=1; 
                }
            pressTime=0;
            down=0;
            insBuff.shootMulti=0;
        }
    }
    else if(switch_is_down(rc_p->rc.s[SHOOT_MODE_CHANNEL]))
    {
        down=1;
        if(pressTime<PRESS_LONG_TIME)
            pressTime+=SHOOT_CTRL_TIME;
        else    //已经按了足够长的时间了，可以不用再增加了，
        {
            insBuff.shootMulti=1;
        }
    }
    pressTimeDebug=pressTime;
}
//需要测试能否解析控制.

```

在解析指令后，为了管理的方便，将指令放入控制结构体。

```c
//**********缓冲指令
struct InstructBuff_s{
    uint8_t turnOnFric  ; //为1时表示指令开启摩擦轮，为0时表示指令关闭摩擦轮
    uint8_t shootOne    ;
    uint8_t shootMulti  ;
};

```

为了避免命令冲突，同一种类型的指令只留一个。例如一开始有turnOnFric和turnOffFric两个指令，但由于他们逻辑相反，实际上并不独立，因此取消了turnOffFric缓冲区。

为了更好控制拨弹轮圈数，使用结构体变量管理。

```c
//**********拨弹轮ECD圈数监控器
struct milestoneStack_s {
    uint8_t head;
    uint8_t stack[MILESTONE_NUMBER+1];
};

struct TriggerControl_s{
    struct milestoneStack_s mstack; //里程碑栈
    const uint16_t * ECDPoint;           //电机ECD所在位置
    uint16_t    initECD;                //初始ECD
    uint16_t    nowECD;                 //现在的ECD
    int16_t     nowRounds;              //现在转过的圈数
};

```

在控制结构体里保存了电机ECD的指针和更新的ECD值。初始化时更新指针，在循环读取ECD的值。

监控圈数算法和云台yaw电机的一模一样，只不过threshold不同。这里因为减速电机的减速前的轴速度快，ECD采样不精准，因此放大里程碑范围。

```c
//*************************里程碑栈法的控制参数***********//
#define MILESTONE_NEAR_THRESHHOLD 2000
#define MILESTONE_NUMBER 3

```

在摩擦轮状态切换函数中，考虑了当拨弹轮转动时，摩擦轮关闭会导致卡弹，因此如此做缓冲设计。当拨弹轮已经回到停止状态时，关闭摩擦轮。就像虽然着急着关门，但是还是要等同学走出去了再关，同学在门口是不能关门的。

```c
static void fricModeChange(void)
{
    //等待拨弹轮关闭时再关闭摩擦轮
    if((!(insBuff.turnOnFric)) || (*robotMode)==RobotState_e_Powerless)
    {
        if(triggerMode==TriggerMode_e_Stop)
        {
            fricOn=0;
            insBuff.shootMulti=0;
            insBuff.shootOne=0;
            insBuff.turnOnFric=0;
        }
    }
    else
    {
        fricOn=1;
    }        
}
```

拨弹轮的状态转换。直接实现拨弹轮状态机所描述的控制流程。对不同状态枚举，在不同状态做不同状态做的事情。在单发控制里，有一点和初始设计不一样。最初，以为减速电机转4圈就是发射一颗了。然而编写调试用代码进行实际实验，让电机转了32颗子弹位置，结果电机圈数显示144圈。知道应该是4.5圈发射一颗。导致转多了后，按下鼠标结果子弹没有发射。改进方案：修改ECD监控算法，能够监控半圈。但是如今ECD采样精度不够，如何更精准监控呢？增加微动开关，反馈调节？但目前没有微动开关。最后想到让电机转动圈数阈值在4和5随机切换，而后又改为普通的相互切换，每次的误差可以忽略，并且没有累计误差，实现了短周期平均4.5圈的控制。所以有了TRIGGER_ROUNDS_FOR_A_BULLET_A和B，分别是4和5.

```c
static void triggerModeChange(void)
{
    static uint32_t lastShootMultiTime=0;
    static uint32_t nowTime=0;
    nowTime=HAL_GetTick();
    
    if(!fricOn) //摩擦轮关闭状态，始终让拨弹轮关闭
    {
        triggerMode=TriggerMode_e_Stop;
        return;
    }
    //对每个状态枚举
    if(triggerMode==TriggerMode_e_Stop)
    {
        //机器人不处于无力状态时，接收从stop状态转变为其他状态的指令
        if((*robotMode)!=RobotState_e_Powerless)
        {
            if(insBuff.shootOne)
            {
                triggerMode=TriggerMode_e_ShootOne;
                insBuff.shootOne=0; //清除缓冲的指令
            }
            else if (insBuff.shootMulti)
            {
                triggerMode=TriggerMode_e_ShootMulti;
                insBuff.shootMulti=0;   //清除缓冲的指令
            }
                
        }
    }
    else if(triggerMode==TriggerMode_e_ShootOne)
    {
        static uint8_t nowTimeRoundThreshold=TRIGGER_ROUNDS_FOR_A_BULLET_A;
        //让拨弹轮转动，当逆时针转到4圈时（这是由于机械结构的原因），清除圈数进入stop
        if(triggerCtrl.nowRounds<=(-nowTimeRoundThreshold)||triggerCtrl.nowRounds>=nowTimeRoundThreshold)
        {
            triggerMode=TriggerMode_e_Stop;
            triggerCtrl.nowRounds=0;
            if(nowTimeRoundThreshold==TRIGGER_ROUNDS_FOR_A_BULLET_A)
                nowTimeRoundThreshold=TRIGGER_ROUNDS_FOR_A_BULLET_B;
            else
                nowTimeRoundThreshold=TRIGGER_ROUNDS_FOR_A_BULLET_A;
        }
        //否则留在这个状态
    }
    else if(triggerMode==TriggerMode_e_ShootMulti)
    {
        if((nowTime-lastShootMultiTime)>=SHOOT_MULTI_TIME_GAP)
        {
            lastShootMultiTime=nowTime;
            triggerMode=TriggerMode_e_ShootOne;
        }
    }

}
```

之后的设置速度和PID控制、发送电流和v15的naive的任务是一样的。但是在v30.10的任务文件名却叫做naive_shoot_task.c，代码依然有许多可以改进的地方，机器人控制优化无止境。我们要stay foolish, stay hungry.**我们的故事，就是从最初那个naive的任务开始的。**



###### 未来的弹道实验

实验计划：控制机器人云台水平，固定指向，用复写纸单发，测量平均下落距离。自己设计制造测速模块。绘制PID目标速度、弹速的关系，绘制弹速、下落距离、水平距离的关系。实验后，与视觉组联合开发自动控制程序。



### 调试的方法

**不要抱侥幸心理。即便你的代码没错，编译器也可能出错**（这时需要加括号、将语句写成更简单的方式，减轻编译器负担）。所以需要用OLED模块或者USB通信模块将变量值打印到屏幕上，实时监控变量的值。输出了所有的值，就能够知道工作状态，一眼发现问题出在哪里。需要一个模块一个模块测试，比合并起来调试却找不到问题要快速得多。

##### 按键+数据变化

最开始的版本，还没有构建出机器人整体（甚至单个模块都没有）的代码，异想天开使用按键和单独的调试任务给某一个任务以不同的输入。然而代码却出错了，无法编译通过。况且这样的方法什么也看不到，于是这个方法还没启用，就抛弃了。

##### OLED显示方法

在编写的过程中，一开始是依靠手工OLED显示显示参数。在编写了多个混乱的OLED调试版本后，终于在一个版本的程序中总结了OLED显示在任务中的三段式调试方法。最初的OLED调试日志参考电控群内《步兵1调试日志（OLED）2022年1月16日18点24分》

常见OLED模块是靠I2C或者SPI总线通信实现的数据传输。可以用只有4根线的模块，其中一个电源一个接地两根信号线。绘制字符和图形的方法是向内存中输出点阵信息。所有函数封装起来。对于调试很重要的有几个函数：

OLED模块要初始化才行。一般可以在任务函数中执行初始化或者在进入main函数后、开启freertos调度前进行初始化。

```c
OLED_init();
```

清空OLED屏幕上的数据。或者可以用数据几排空格代替。

```c
OLED_operate_gram(PEN_CLEAR);
```

像使用标准库函数printf一样在OLED内存区内输出数据。需要指定行和列。

```c
/**
 * @brief   formatted output in oled 128*64
 * @param   row: row of character string begin, 0 <= row <= 4;
 * @param   col: column of character string begin, 0 <= col <= 20;
 * @param   *fmt: the pointer to format character string
 * @retval  None
 * @note    if the character length is more than one row at a time, the extra characters will be truncated
 */
extern void OLED_printf(uint8_t row, uint8_t col, const char *fmt,...);

```

将数据发送到OLED屏幕上。只有执行了这句语句才能更新OLED显示的数据。另外，这个输出刷新频率不能太快。

```c
/**
 * @brief   send the data of gram to oled sreen
 * @param   none
 * @retval  none
 */
extern void OLED_refresh_gram(void);
```

普通控制任务（例如底盘控制任务）每两次执行的时间间隔在5ms的量级。以这个频率刷新好像会产生干扰信号。（使用C板的用户自定义SPI总线）所以需要对控制进行延时刷新。因此有了三段的控制方法：宏定义确定调试参数，定义用于调试的全局变量，在while(1)循环内编写输出和延时刷新语句。

使用前先将OLED.c,OLED.h,oledfont.h函数放在工程文件里。

以v17版本的代码为例。这一个版本的代码有风格写得较好的底盘控制任务（但可惜无法作为整体运行。操作系统会崩溃）。不同的代码相互隔开，数据结构分类，有很详细的注释。最开头有刷新时间定义。

```c
//*****************************debug选项*******************//
// #define AUTO_DETECT_INIT_ECD    //由于比赛时可能会忘记把机器人云台放正，这里默认在没有定义时，使用在调试时看到的数据
//OLED调试相关
// #define OLED_DEBUG_CHASSIS_TASK_ON
#ifdef OLED_DEBUG_CHASSIS_TASK_ON
#define OLED_REFRESH_TIME 300
#endif

```

中间有调试所需的变量定义。它们的作用是复制一些局部变量的值，达到监控一些局部变量的效果。

```c
//***************调试所用变量**************************//
#ifdef OLED_DEBUG_CHASSIS_TASK_ON
static int time_passed_debug=0;
fp32 debug_vx,debug_vy,debug_w;
#endif
```

例如，在计算速度的函数里，有如下的复制方法

```c
static void calcWheelVelocityInChassisAxis(void)   //将控制量中的坐标系速度转化为底盘坐标系的速度，并计算轮子转动速度
{
    //...控制代码
    
    #ifdef OLED_DEBUG_CHASSIS_TASK_ON
    debug_vx=vx;
    debug_vy=vy;
    debug_w=w;
    #endif
}
```

而后，在while(1)循环内，根据时间刷新。用一个变量记录当前经过的时间，每次增加任务调度间隔的时间，判断超过刷新时间时，进行刷新。

```c
while(1)
    {
        //*****************************OLED 显示调试******************//
        #ifdef OLED_DEBUG_CHASSIS_TASK_ON
        time_passed_debug+=CHASSIS_CONTROL_TIME_MS;
        if(time_passed_debug>OLED_REFRESH_TIME)
        {
            time_passed_debug=0;
            //*********输出和更新******************
            OLED_printf(0,0,"                    ");
            OLED_printf(1,0,"                    ");
            OLED_printf(2,0,"                    ");
            OLED_printf(3,0,"                    ");
            OLED_printf(4,0,"                    ");
            // OLED_printf(0,0,"ECD:%d",someAngle.nowGimbalYawECD);
            // OLED_printf(1,0,"vx:%f",debug_vx);
            // OLED_printf(2,0,"vy:%f",debug_vy);
            // OLED_printf(3,0,"w:%f",debug_w);
            // OLED_printf(0,0,"i4:%d",robotTotalSpeedControl.vx);
            // OLED_printf(1,0,"i1:%d",driveMotor[0].giveCurrent);
            // OLED_printf(2,0,"i2:%d",driveMotor[1].giveCurrent);
            // OLED_printf(3,0,"i3:%d",driveMotor[2].giveCurrent);
            // OLED_printf(4,0,"i4:%d",driveMotor[3].giveCurrent);
            OLED_printf(0,0,"%d",rc_p->rc.ch[CHASSIS_X_CHANNEL]);
            OLED_printf(1,0,"%d",rc_p->rc.ch[CHASSIS_Y_CHANNEL]);
            OLED_printf(2,0,"%d",rc_p->rc.ch[CHASSIS_W_CHANNEL]);
            
            OLED_refresh_gram();
            //***********************************
        }
        #endif
        //***********************************************************//
		
    	//...一些控制代码

        osDelay(CHASSIS_CONTROL_TIME_MS);
    }
```

OLED调试的方法进一步完善，就是新建一个任务，实现一定时间间隔输出和刷新。

##### 追踪程序是否进入某个位置：蜂鸣和LED灯法

2021年的联盟赛期间，比赛的某一天晚上，靠我们开朗外向的操作手学长，我到隔壁和西工大的同学们交流。那时很巧，我们两个队住在隔壁。那时我还是大一，只学了数学和物理，程序依然停留在高中自学水平。有一位西工大的材料系学长教我调试程序：**判断程序是否到达某一个地方，得让它执行一些功能，比如让灯翻转一下**。而后我知道了得 调试 程序，而不是改几个变量，看能不能碰运气正好改到了错误。

LED灯已经用来作为机器人操作系统工作状态的指示了（如果freertos崩溃了，那么灯就不会继续变颜色了）。所以可以使用蜂鸣器来指示程序有无运行到某个地方。

相关函数在bsp_buzzer相关文件里。原理是调节频率、pwm输出。封装好了就留下buzzer_on和buzzer_off函数了。

比如在v14版本的程序中，还没有完全使用OLED作为调试方法。需要引用头文件。

```c
#include "bsp_buzzer.h"
```

在相应地方增加 turn_on_buzzer();当时不知道任务有没有被调度，于是增加了一个开启指令，当程序执行到此处，蜂鸣器开启，说明程序运行到了这个地方。

```c
void chassis_move_task()
{
    
    osDelay(CHASSIS_TASK_INIT_TIME);
    initPIDs();
    rc_p=get_remote_control_point();
    // turn_on_buzzer();
    while(1)
    {
       //...
    }
}
```

但是只有响一次的数据量。如果增加数据量会比较复杂。因此后来用得不多，都改用OLED和usb口了。

##### 大量数据：usart com 串口数据输出

在电控群里让大家讨论实现串口输出调试。最终经过大家的努力一起完成了《v_printDebug_3_succeed_2022年1月30日》，和使用说明文档。但那个版本没有DMA输出，会比较消耗CPU执行时间。并且usart1被用于和NUC进行串口通信，一些配置不宜修改。但是在开发初期，依然可以作为一种简易的调试方式。

依然以v14版本的程序为例，首先需要复制做好的串口通信相关函数文件和头文件到工程文件里面（操作过程总结在上述文档内）。在需要调试的地方包含输出头文件。

```c
#include "usartPrintDebug.h"
```

在chassis_task.c的开头增加宏定义

```c
// #define DEBUGGING
#if defined DEBUGGING
// put print code inside #if #endif
#endif
```

在待调试的地方输出。

```c
static void calcNeededMotorSpeed(void)
{
    wantedVMotor[0]=-vx+vy-w;
    wantedVMotor[1]=vx+vy-w;
    wantedVMotor[2]=vx-vy-w;
    wantedVMotor[3]=-vx-vy-w;
    int i;
    #if defined DEBUGGING
    usart_printf("----------------------------------\n");
    for(i=0;i<4;i++)
    {
        usart_printf("wanted Motor[%d] speed:%f\n",i,wantedVMotor[i]);
    }
    usart_printf("-----------------------------------\n");
    #endif
}
```

调试串口输出的时候一般是\r\n才是换行。这个方法会占usart串口，后来发现usb的调试功能后，换用了usb。

##### 大量数据：USB输出

为了尽可能获得C板所有的性能和功能，避免不完善的文档造成的重复造无效轮子工作，在v21版本程序崩溃后，使用了官步的框架。将三个关键控制任务从官步中删除了，留下了底层。

在底层发现有USB任务。在usb_task.c中，有代码直接输出了所有遥控器数据。如何接收和调试？

```c
        usb_printf(
"******************************\r\n\
voltage percentage:%d%% \r\n\
DBUS:%s\r\n\
chassis motor1:%s\r\n\
chassis motor2:%s\r\n\
chassis motor3:%s\r\n\
chassis motor4:%s\r\n\
yaw motor:%s\r\n\
pitch motor:%s\r\n\
trigger motor:%s\r\n\
gyro sensor:%s\r\n\
accel sensor:%s\r\n\
mag sensor:%s\r\n\
referee usart:%s\r\n\
******************************\r\n",
            get_battery_percentage(), 
            status[error_list_usb_local[DBUS_TOE].error_exist],
            status[error_list_usb_local[CHASSIS_MOTOR1_TOE].error_exist],
            status[error_list_usb_local[CHASSIS_MOTOR2_TOE].error_exist],
            status[error_list_usb_local[CHASSIS_MOTOR3_TOE].error_exist],
            status[error_list_usb_local[CHASSIS_MOTOR4_TOE].error_exist],
            status[error_list_usb_local[YAW_GIMBAL_MOTOR_TOE].error_exist],
            status[error_list_usb_local[PITCH_GIMBAL_MOTOR_TOE].error_exist],
            status[error_list_usb_local[TRIGGER_MOTOR_TOE].error_exist],
            status[error_list_usb_local[BOARD_GYRO_TOE].error_exist],
            status[error_list_usb_local[BOARD_ACCEL_TOE].error_exist],
            status[error_list_usb_local[BOARD_MAG_TOE].error_exist],
            status[error_list_usb_local[REFEREE_TOE].error_exist]);
```

打开串口通信调试助手，可以在连接USB串口后，在下拉列表发现USB串行设备，随便选波特率都没关系。开启串口，收到了数据。十分稳定和方便。只需要一根USB线就可以接收数据和调试了，不需要其他的转换模块等。

在v30.5的调试中，使用如下方式输出待调试的程序。相比于下面的方法其实比较傻。

```c
#ifdef GIMBAL_DEBUG_SHOW
        // uint8_t i;
            // for(i=0;i<GIMBAL_DEBUG_SHOW_SERIES_NUMBER;i++)
                usb_printf("%s:%f\r\n%s:%f\r\n%s:%f\r\n%s:%f\r\n%s:%f\r\n%s:%f\r\n%s:%f\r\n%s:%f\r\n%s:%f\r\n%s:%f\r\n%s:%f\r\n",things[0].name,things[0].value,
                things[1].name,things[1].value,things[2].name,things[2].value,
                things[3].name,things[3].value,things[4].name,things[4].value,
                things[5].name,things[5].value,things[6].name,things[6].value,
                things[7].name,things[7].value,things[8].name,things[8].value,
                things[9].name,things[9].value,things[10].name,things[10].value);
        #endif
```

这些thing是传递参数所使用的数据结构体，包含名称和fp32的值。当时也是不知道该怎样传递参数才好。

```c
struct gimbalToShow_s{
    char *name;
    fp32 value;
};

```

在naive_gimbal_task.c中，有名称初始化和值的存放。

```c
for(i=0;i<GIMBAL_DEBUG_SHOW_SERIES_NUMBER;i++)
        debuggShows[i].name="Blank";
    debuggShows[0].name="wantRad/s";
    debuggShows[1].name="now rad/s";
    debuggShows[2].name="now time";
    debuggShows[3].name="volt";
    debuggShows[4].name="p";
    debuggShows[5].name="i";
    debuggShows[6].name="d";
    debuggShows[7].name="nothing";
    debuggShows[8].name="limited target angle by down";
    debuggShows[9].name="roundsnow";
    debuggShows[10].name="roundslimit";
```

经验教训是：**如此多的数据，首先要在纸上写出来想要看哪些变量，规划好位置后，在各个函数的不同部分给变量赋值**。

例如在调试角度限制算法时，需要知道从遥控器指令传过来初始的角度，和限制后的角度。

```c
// // for debug
    // if(c==&gimbalPitchCtrl)
    // {
    //     debuggShows[1].value=(fp32)c->wantedAbsoluteAngle;
    //     debuggShows[2].value=(fp32)posiSafe;
    //     debuggShows[3].value=(fp32)negSafe;
    //     debuggShows[4].value=(fp32) radFormat(c->wantedAbsoluteAngle - c->nowAbsoluteAngle);
    //     // debuggShows[5].value=(fp32) radFormat(c->wantedAbsoluteAngle - c->nowAbsoluteAngle);
    //     debuggShows[5].value=(fp32)( radFormat(c->wantedAbsoluteAngle - c->nowAbsoluteAngle) >posiSafe);
    //     debuggShows[6].value=(fp32)(radFormat(c->wantedAbsoluteAngle - c->nowAbsoluteAngle)<negSafe);
        
    // }
    debuggShows[9].value=c->nowRounds;
    debuggShows[10].value=c->maxRounds;
```

也是在这里，发现了一些奇怪的现象，怀疑是编译器出错了。

这里每个条件判断都是连续的两个。最开始写成了 &&的形式，但是输出被&&连起来的两个表达式后，得到不应该进入下方的条件限制，然而实际上运行时却出错了，无论如何角度都被限制到了边上，即便并不满足限制条件。于是将if表达式改写为了两条分开的，而后编译，程序运行正常。因此，输出变量的值对于面向过程编程非常重要。目的是获得能够运行的代码完成任务，中间有啥不重要的问题能够避开就行了。

```c
if((c -> nowRounds >= c -> maxRounds))
        if(radFormat(c->wantedAbsoluteAngle - c->nowAbsoluteAngle) >posiSafe)
            // debuggShows[7].value=(fp32)HAL_GetTick();
            debuggShows[7].value=radFormat((fp32)(c->nowAbsoluteAngle+posiSafe));
    if((c->nowRounds <= (0-(c->maxRounds))))
        if(radFormat(c->wantedAbsoluteAngle - c->nowAbsoluteAngle)<negSafe)
            // debuggShows[8].value=(fp32)HAL_GetTick();
            debuggShows[8].value=radFormat((fp32)(c->nowAbsoluteAngle-negSafe));
```

后来太过麻烦，使用了一个函数作为缩写。从侧面印证了这个方式确实很麻烦。

```c
void pv(uint8_t i,fp32 v)
{
    debuggShows[i].value=v;
}
```

在v30.5的调PID程序中，使用的就是usb口输出和这种复杂的方法。若直接使用这版程序调PID，需要明确它使用的方法（上文所述）和数据流向。外挂testspd的意思是把遥控器输出直接映射到目标角速度上。输出到屏幕上。由于角速度难以直接感知，所以真实角速度和目标角速度都要输出。

```
//******************************开启外挂testspd************//
        int a=1;
        #ifdef YAW
        a=1;
        #else 
        a=0;
        #endif
        test_want_spd=(fp32) rc_p->rc.ch[3]/660.0f;
        
        pv(0,test_want_spd);
        pv(1,gimbalCtrl[a]->radSpeed);
        pv(2,(fp32)HAL_GetTick());
        // pv(3,gimbalCtrl[a]->giveVolt);
        pv(4,gimbalCtrl[a]->spd_pid.Kp);
        pv(5,gimbalCtrl[a]->spd_pid.Ki);
        pv(6,gimbalCtrl[a]->spd_pid.Kd);
```

usb口在c板的边缘，接线后，只好用一个线来把C板绑在云台上。不过只要够紧不掉就行。（想当年，别的队用扎带，我们用风筝线捆电线）

##### 单独OLED任务+打印函数

终于到**最简单的方法**了。

例如2022.2.14这天测试NUC的数据接收情况时，在NUC接收相关代码（nucCommu.c）中增加了一个函数。参考《视觉电控接口for第一阶段简易自瞄2022年2月14日》

```c
void OLED_nuc(void)
{
    OLED_printf(0,0,"s:%c,task:%d,tht:%f,phi:%f,r:%f,color:%d,end:%c",
    (char)(nuc_ctrl.startFlag),nuc_ctrl.taskType,nuc_ctrl.theta,nuc_ctrl.phi,nuc_ctrl.r,nuc_ctrl.detectedColor,(char)(nuc_ctrl.endFlag));
}
```

由于这个函数编写在NUC接收数据相关代码中，它对于这些变量的引用是直接的，不需要使用复杂的参数传递方法将变量传到OLED任务函数中去。而后，直接利用OLED_task的顺风车：OLED_task定时刷新内存。

需要在OLED_task里声明这个函数。为了统一管理，增加宏定义开启和关闭输出。

```c
#define SHOW_NUC_DATA
```

```c
void OLED_nuc(void);
```

while(1)循环内部分代码如下：

```c
OLED_operate_gram(PEN_CLEAR);

#ifdef SHOW_NUC_DATA
                OLED_nuc();
#endif 
                OLED_refresh_gram();
```

只从最左上方的位置开始显示，程序会自动换行。显示不稳定，值会飘，且拨动，在freertos中关闭了caliberate_task后，完成了稳定显示。也是保护了nuc数据区吧。

为啥简单呢？printf像一辆大车，让车跑到人多的地方，接大家走，比让大家走到车旁边要省力气。

##### 虚拟机器人程序测试环境

一开始，在参数不确定的情况下，对于纯算法上的代码，可以先自己编写仿真平台测试（就是一个像五子棋工程文件一样的东西，相信大家在上了C语言课，进行了五子棋比赛后就会写这个仿真平台了）。例如PID计算函数仅仅包含数学计算，不涉及机器人的参数，因此可以编写Windows程序计算一定输入下的输出。一些其他关于类型转化、格式化函数，也可以Windows上的C程序验证。

机器人的整个控制任务也放到虚拟环境中测试。为任务调用的函数提供空函数或者延时函数接口，将发送函数用输出函数代替，用输入函数替代读取函数，可以验证整个机器人控制流程的正确性，并且非常方便地观察值。当程序逻辑出现错误时，还可以用gdb直接单步追踪和查看变量值，省去了编译烧录的过程。

相关测试代码已经发在电控群内。名称testbench。文档《使用PC模拟测试机器人控制程序2022年1月14日》。

关键是实现能够直接把控制任务源代码放过来的测试环境，在debug后能原封不动装回机器人控制工程代码中并正确执行。所以要分层：真正的层在一起，虚拟的层在标注好的文件夹内。灵活使用宏定义。有的虚拟的层可以直接赋值机器人中的层而后注释掉一些内容。

编译执行命令

```
gcc *.c ./virtualLayer/*.c -I ./virtualLayer -I . -o testChassisRun -g 
testChassisRun
```

能够找到一些问题，如参数的大小问题。

> 使用此虚拟机器人环境，在命令行中测试函数的输入输出，可以观察电机电流值，此处，调试参数，发现giveCurrent计算过小，可能是这个原因导致了机器人底盘无法运动。（实际测试时，发送电流大约1000时，机器人底盘3508电机才开始运动）![img](D:/大学课外/RM2022/电控/notes/电控代码设计说明/image/clip_image002.png)



由于手边有真正的机器人以及OLED、USB、usart串口等调试方法的研究，这个虚拟测试环境没有继续开发。未来其实可以在底层增加一些参数，能模拟真实的机器人电机参数，从而让大家在安全的前提下测试自己的机器人控制程序。但是，虚拟的无法替代真实的，需要上真车调试。

另外，用于仿真的平台也有bug，所以为了debug得先de debug程序的bug。orz

##### 用遥控器调PID设计

在调试过程中有一些创意，灵感，可以去实现。例如v13版本程序的遥控器调PID的程序。遥控器很多摇杆和拨杆，可以用于选择PID参数、提交、映射控制量等。很快就实现了。文档《通过遥控器和OLED动态调节PID参数2022年1月17日》。

虽然这个方法很便捷，可以远程调参，避免危险，且不需要附加设备，体现了程序智能弥补硬件缺失，但是编写过程还是有点复杂，且破坏了原有的任务结构。所以未来可以将这个PID调试方法作为一个单独的freertos任务，通过遥控器更改值，发送到需要调PID的任务中去。并且这个任务可以是智能的：自动调节PID参数。

v30.5调节云台PID时，没有再用这个方法。原因是重新改程序、编译、上传、按下复位键，就够用了，不需要花费过多力气重新编写遥控器调PID程序。这个方法的未来，在于自动调参。

##### 编辑器推荐

别用uvision直接打代码，眼睛受不了。可以用VScode，调个黑色背景。

这篇文档是使用Typora写的，格式markdown。直到2022年2月15日18：00我才发现这个程序主题色可以调成黑的。白色眼睛快瞎了。这里面加代码和写出目录很方便。



### 操作手指南

注：所有模式都可以重新设计，想实现任何功能都可以和电控组交流。

操作手**若熟悉电控代码设计思路和具体实现，就容易在赛场上处理应急情况**。当然，任何同学只要**训练得足够多**，**和电控队员交流得多**，都可以非常熟悉机器人的控制性能。

机器人在场上完成任务。半自动机器人靠操作手控制移动，可以靠计算机自动瞄准。操作手的界面与第一人称射击游戏相同。机器人搭载的图传模块将视频信号发送给操作手的电脑。而操作手在键盘、鼠标上的操作会通过遥控器发送到机器人上的遥控器接收机。接收机接收的是遥控器摇杆、拨杆、键盘按键是否按下（Q,W,E,R,A,S,D,F,G,SHIFT,Z,X,C,V,B,CTRL），鼠标移动速度。电控程序包含机器人如何根据这些指令移动的信息。

##### 安全说明

当遥控器离线时，机器人进入无力模式，各个机构发送零电流。这也可以用于在赛场上不用关闭总电源的前提下让机器人底盘无力，方便推动。遥控器重新上线时，机器人会根据遥控器右上方拨杆的位置确定模式。上——普通车；中——小陀螺；下——卡yaw车。注意这可能导致遥控器上线时机器人就开始小陀螺旋转，需注意安全。

##### 模式设计说明

除了离线的无力模式外，机器人有三个工作模式。各个模式有不同特点，在键鼠操作和遥控器操作上相互补充。遥控器总体的思想是：左边摇杆等价于键盘，右边摇杆等价于鼠标。

###### 模式切换方法

三个模式都可以通过按键或者遥控器右拨杆的移动切换。键盘和拨杆冲突时，以**最新变化**的控制器（键盘或者遥控器拨杆）的命令为准。

键盘CVB分别顺序对应三个模式，遥控器右上拨杆上中下也分别顺序对应三个模式。

###### 普通车模式（Common car)：完整运动（C 上）

机器人底盘可以直接实现复杂的运动，包括任意方向平移和附加旋转。机器人的移动复杂度其实受限于操作手的指令的简单性和遥控器通道的不足。普通车模式是为了完整实现机器人的所有行为。设计的键盘按键有前后左右平移和顺逆旋转，为底盘坐标系控制，亦即，以机器人的底盘而非操作手的视角为前后左右的参照。鼠标控制云台的单独的旋转。

按C键进入，取common car的首字母，方便记忆。或者将右拨杆移到上方。

左边摇杆只能控制前后平移和旋转，不能控制左右平移。右边摇杆控制云台绝对角度变化。

键盘ed：前后平移；键盘sf：逆时针和顺时针旋转；键盘ag：左右平移；

Auto时，NUC控制云台独立旋转。

###### 小陀螺模式：避弹（V 中）

小陀螺模式。为了给对方自瞄程序带来干扰，底盘持续自动转动，而云台发射机构一直面对对方机器人。底盘根据机械结构宏定义文件自动确定是小陀螺还是准小陀螺。无电滑环的准小陀螺模式下，机器人底盘在旋转一定圈数后会反向转动一定圈数，从而避免线被绕断。

右拨杆在中时进入，或者键盘按V时进入。原因是V长得像一个陀螺。遥控器左摇杆控制在云台坐标系下的前后左右平移，右摇杆控制云台旋转。 Auto时， NUC控制云台独立方向。



###### 坏yaw（卡yaw）模式：应急 （B 下）

坏yaw 车模式，考虑比赛中yaw轴可能卡住的意外情况。卡住时，操作手可以手动进入此模式时，程序会尝试回正云台，一定时间内回正不了就自动放弃并在此模式中向yaw轴电机发送0电流。wsad控制前后左右平移，鼠标pitch上下和整体旋转。此时，遥控器左边摇杆控制机器人在云台坐标系中前后左右平移。

拨杆在下时进入，以及键盘按B时进入。原因是取Bad yaw 的首字母B。

为了继续保证机器人的云台转向和自瞄功能，Auto模式NUC控制云台pitch和机器人整体转向。实现的原理是角度PID控制输出的角速度乘以系数后交给底盘控制任务，底盘执行此旋转指令。



键盘和鼠标控制

| 模式     | 底盘控制视角 | 键盘                                      | 鼠标                             |
| -------- | ------------ | ----------------------------------------- | -------------------------------- |
| C普通车  | 底盘本身     | ED前后平移，SF底盘左右旋转,AG底盘左右平移 | 云台上下左右旋转                 |
| V小陀螺  | 云台视角     | WS前后平移，AD底盘左右平移                | 云台上下左右旋转                 |
| B坏yaw车 | 云台视角     | WS前后平移，AD底盘左右平移                | 云台上下旋转、机器人整体左右旋转 |

只有遥控器的情况下的控制

| 模式     | 底盘控制视角 | 遥控器左摇杆           | 遥控器右摇杆                     |
| -------- | ------------ | ---------------------- | -------------------------------- |
| C普通车  | 底盘本身     | 前后平移，底盘左右旋转 | 云台上下左右旋转                 |
| V小陀螺  | 云台视角     | 前后平移，底盘左右平移 | 云台上下左右旋转                 |
| B坏yaw车 | 云台视角     | 前后平移，底盘左右平移 | 云台上下旋转、机器人整体左右旋转 |



###### 射击说明

射击的设计代码说明中，有相关操作设计和原因的说明

> 发射涉及两种电机。一个拨弹轮在弹舱内，起到输送荧光弹的作用；两个摩擦轮（摩擦力很大）的驱动电机在炮口位置。荧光弹的大小略小于弹性摩擦轮之间的间隙。为了发射子弹，需要首先开启摩擦轮，待摩擦轮速度增加到很高时，让拨弹轮转动，将子弹推到摩擦轮前，发射出去。如果摩擦轮未转动，而拨弹轮却将子弹推到了摩擦轮前，就会导致卡弹。

> 遥控器离线时关闭发射机构所有相关电机，Shift键开启摩擦轮。遥控器左上拨杆上拨后移到中间，可以开启或关闭摩擦轮。当遥控器左拨杆移到中间时，允许鼠标控制发射。鼠标左键按下后立刻抬起，发射一颗子弹；左键按住不放，连发。鼠标右键按下不放：允许NUC控制发射单发或者连发。当然，遥控器左上拨杆也可控制发射。在摩擦轮开启的前提下，置于下端，而后立刻置于中间，发射一颗子弹；置于下端不停，连发。键盘开启键设计原因如下：虽然在比赛过程中，不需要关闭摩擦轮，键盘开启和关闭按钮似乎多余，但是实际比赛过程中，操作手距离机器人很远，看不到摩擦轮是否开启。为了能够确保摩擦轮开启，设计一个shift键，只能发送开启摩擦轮的命令。而不在键盘上留关闭摩擦轮的按键，目的是防止操作手误触导致摩擦轮关闭卡弹。

> 这里，长按是通过时间判断的。宏定义中有对长时间的定义，可以根据操作手的习惯修改时间。
>
> ```c
> #define PRESS_LONG_TIME     700    //长时间按住的定义为700ms，700个时钟周期
> ```

> 射频也可以在宏定义中修改。
>
> ```c
> //**************射击电机控制常量
> #define SHOOT_MULTI_FREQUENCY   6       //射击频率：个/s
> #define SHOOT_MULTI_TIME_GAP    (1000/SHOOT_MULTI_FREQUENCY)    //连发射击时间间隔
> #define SHOOT_SPEED_LIMIT 0.3f          //摩擦轮速度。未来可以测试摩擦轮速度和射速的关系
> #define SHOOT_TRIGGER_SPEED_LIMIT 0.25f   //拨弹轮开启时速度
> 
> ```



###### 自瞄说明

在键盘上按Z键开启自瞄（取“自”的拼音首字母Z），按X键关闭自瞄进入手动模式并且清除自瞄修正偏移量。鼠标右键按住不放，允许NUC控制发射。

开启自瞄后，机器人云台会根据NUC反馈的角度旋转，直到让待击打位置到达摄像机画面中心。因为自瞄可能有误差，允许操作手手动设计偏移量。在按下Z键后，操作手对于鼠标的操控将转化为偏移量：对于自瞄角度的偏移。例如，当操作手上移鼠标一段距离后不动，那么机器人将会自动瞄准到新的位置，这个位置是相对于原来的自瞄结果上方一段距离的位置。这是操作手和NUC合作瞄准。这个偏移量会一直生效。

当操作手希望清除这个偏移量时，可以按下X键，像一个叉叉取消掉自瞄，机器人进入手动模式，清除刚才的偏移量（亦即上文的“修正偏移量”）。重新按Z键，可以恢复自瞄，以零偏移开始。

当NUC掉线时，机器人会立刻进入手动模式。掉线是根据NUC发送的数据帧的时间判断的。

当开启自瞄模式、但NUC未找到装甲板时，机器人切换到手动模式，但是修正偏移量会保存下来，不被清空。当下一次遇到装甲板时，机器人会立刻进入自瞄模式，并在2s之后允许操作手增加新的偏移量（这是为了避免在发现装甲板的一瞬间操作手的鼠标运动会破坏刚刚修正好的偏移量）。

### 待完成的工作

自瞄模式的联合测试

小陀螺运动模式，反向转动时速度切换不够丝滑，机器人会产生很大的振动。

陀螺仪零飘。解决方法：可以统计一段时间内零飘的量，而后按照零飘历史自动补偿。

弹道实验优化

发射槽的长度过长，导致有子弹存储于摩擦轮前方。当机器人pitch下落时，存储在槽内的子弹会掉出去。我们可以在发射槽位置增加一个簧片，既能储存一颗子弹，又能避免它掉出去。可以3D打印这些零件

云台卡住的时候自动切换云台状态。避免电流过大。

卡弹时的控制方法：1）抬头，拨弹轮倒转，摩擦轮正转加速；2）摩擦轮一边正转，另一边发送零电流，加速到一定程度后，零点流端制动。结合两种控制方法

自动控制发射和旋转。

发射过来的子弹的躲避。

超声波模块自动避障

......

### One more word

一路走来，虽然有些艰难，也曾在困苦中怀疑意义，但一边思考一边坚持下来，会遇到好多风景。努力到达的地方足够让我们欣喜。







